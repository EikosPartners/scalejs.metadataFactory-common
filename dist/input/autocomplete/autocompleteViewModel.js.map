{"version":3,"sources":["../../../src/input/autocomplete/autocompleteViewModel.js"],"names":["autocompleteViewModel","node","inputViewModel","context","dataSourceEndpoint","keyMap","options","unique","inputValue","subs","mapItem","itemMapper","autocompleteSource","values","sourceArray","validations","computedSource","autocompleteSourceDef","console","warn","cloneDeep","mapAutocompleteSource","source","map","src","value","label","getAutocompleteSource","ajax","error","data","dataKey","mappedData","d","retVal","textKey","valueKey","Array","isArray","k","join","delimiter","id","uniqBy","item","filter","Boolean","SearchResults","getAutocompleteSourceFromContext","toArray","fromArray","getValue","text","original","push","extend","deferred","addNew","autocomplete","message","params","subscribe","oldValue","remove","newValue","deleteFlag","deleted","read","selectedItems","difference","newSource","differenceBy","write","newValues","mappedChildNodes","dispose"],"mappings":"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","file":"autocompleteViewModel.js","sourcesContent":["import { observableArray, computed } from 'knockout';\r\nimport { evaluate } from 'scalejs.expression-jsep';\r\nimport { has } from 'scalejs';\r\nimport dataservice from 'dataservice';\r\nimport _ from 'lodash';\r\n\r\n\r\n// TODO: Refactor multi-input functionality out or to its own viewmodel\r\n\r\nexport default function autocompleteViewModel(node, inputViewModel) {\r\n    const context = this,\r\n        dataSourceEndpoint = node.dataSourceEndpoint,\r\n        keyMap = node.keyMap || {},\r\n        options = node.options || {},\r\n        unique = options.unique,\r\n        // inputViewModel\r\n        inputValue = inputViewModel.inputValue,\r\n        subs = inputViewModel.subs,\r\n        mapItem = inputViewModel.mapItem,\r\n        itemMapper = mapItem(keyMap),\r\n        // todo: just use values\r\n        autocompleteSource = inputViewModel.values;\r\n        // props\r\n    let sourceArray,\r\n        validations,\r\n        computedSource,\r\n        autocompleteSourceDef;\r\n\r\n    if (node.autocompleteSource) {\r\n        console.warn('[autocomplete] please move the autocompleteSource into options');\r\n        autocompleteSourceDef = _.cloneDeep(node.autocompleteSource);\r\n    } else {\r\n        autocompleteSourceDef = _.cloneDeep(node.options && node.options.autocompleteSource);\r\n    }\r\n\r\n    function mapAutocompleteSource(source) {\r\n        return source.map((src) => {\r\n            if (typeof src === 'string') {\r\n                return {\r\n                    value: src,\r\n                    label: src\r\n                };\r\n            }\r\n            return src;\r\n        });\r\n    }\r\n\r\n    function getAutocompleteSource() {\r\n        dataservice.ajax(dataSourceEndpoint, (error, data) => {\r\n            if (error) {\r\n                console.error('Data retrieval failure', error);\r\n                return;\r\n            }\r\n            if (keyMap.dataKey) {\r\n                sourceArray = data[keyMap.dataKey];\r\n                // todo: update to use mapItem\r\n                const mappedData = data[keyMap.dataKey].map((d) => {\r\n                    const retVal = keyMap.textKey && keyMap.valueKey ?\r\n                    {\r\n                        label: (Array.isArray(keyMap.textKey)\r\n                            ? keyMap.textKey\r\n                            : [keyMap.textKey]).map(k => d[k])\r\n                            .join(keyMap.delimiter || ' / '),\r\n                        value: d[keyMap.valueKey]\r\n                    }\r\n                    : d[node.id]; // todo: remove this and add mapping!\r\n                    return retVal;\r\n                });\r\n                autocompleteSource(\r\n                    mapAutocompleteSource(_.uniqBy(mappedData, (item) => {\r\n                        let retVal = '';\r\n                        if (item && has(item, 'value')) {\r\n                            retVal = item.value;\r\n                        }\r\n                        return retVal;\r\n                    }).filter(Boolean))); // remove empty values\r\n            } else {\r\n                sourceArray = data.SearchResults;\r\n                autocompleteSource(mapAutocompleteSource(data.SearchResults));\r\n            }\r\n        });\r\n    }\r\n\r\n    function getAutocompleteSourceFromContext() {\r\n        let source = _.toArray(evaluate(autocompleteSourceDef.fromArray || [], context.getValue));\r\n\r\n        // storing source array before any mapping\r\n        sourceArray = source;\r\n        if (Array.isArray(source)) {\r\n            autocompleteSource(\r\n                _.uniqBy(\r\n                    source\r\n                        .map(itemMapper)\r\n                        // todo: remove additional mapping - using binding options\r\n                        .map((item) => {\r\n                            return {\r\n                                label: item.text,\r\n                                value: item.value,\r\n                                original: item.original\r\n                            };\r\n                        }),\r\n                    (item) => {\r\n                        return item.value;\r\n                    }\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    // function setReadonly(bool) {\r\n    //     readonly(bool);\r\n    // }\r\n\r\n    if (dataSourceEndpoint) {\r\n        subs.push(computed(getAutocompleteSource));\r\n    }\r\n\r\n    if (Array.isArray(autocompleteSourceDef)) {\r\n        sourceArray = autocompleteSourceDef;\r\n        autocompleteSource(mapAutocompleteSource(autocompleteSourceDef));\r\n    }\r\n\r\n    if (autocompleteSourceDef && !Array.isArray(autocompleteSourceDef)) {\r\n        subs.push(computed(getAutocompleteSourceFromContext).extend({ deferred: true }));\r\n    }\r\n\r\n    if (!options.addNew) {\r\n        validations = _.cloneDeep(options.validations) || {};\r\n        if (!validations || !validations.autocomplete) {\r\n            validations.autocomplete = {\r\n                message: 'Please choose a valid selection from the options.',\r\n                params: autocompleteSource\r\n            };\r\n        } else {\r\n            validations.autocomplete = {\r\n                message: validations.autocomplete.message || 'Please choose a valid selection from the options.',\r\n                params: autocompleteSource\r\n            };\r\n        }\r\n    }\r\n\r\n    if (unique) {\r\n        inputValue.subscribe((oldValue) => {\r\n            context.unique[node.id].remove(oldValue);\r\n        }, null, 'beforeChange');\r\n        inputValue.subscribe((newValue) => {\r\n            if (context.deleteFlag && context.deleteFlag()) { return; }\r\n            context.unique[node.id].push(newValue);\r\n        });\r\n\r\n        if (context.deleteFlag) {\r\n            context.deleteFlag.subscribe((deleted) => {\r\n                if (deleted) {\r\n                    context.unique[node.id].remove(inputValue());\r\n                }\r\n            });\r\n        }\r\n\r\n        computedSource = computed({\r\n            read: function () {\r\n                let selectedItems = _.difference(context.unique[node.id](), [inputValue()]).map((item) => {\r\n                        return {\r\n                        value: item\r\n                    };\r\n                    }),\r\n                    newSource = _.differenceBy(autocompleteSource(), selectedItems, 'value');\r\n                return newSource;\r\n            },\r\n            write: function (newValues) {\r\n                autocompleteSource(newValues);\r\n            }\r\n        }).extend({ deferred: true });\r\n    }\r\n\r\n    // console.log('Autocomplete source array:', sourceArray);\r\n\r\n    return {\r\n        autocompleteSource: unique ? computedSource : autocompleteSource,\r\n        validations,\r\n        mappedChildNodes: observableArray(), // todo: still need?\r\n        // setReadonly: setReadonly,\r\n        dispose: () => {\r\n            if (unique) {\r\n                context.unique[node.id].remove(inputValue());\r\n            }\r\n        }\r\n    };\r\n}"]}