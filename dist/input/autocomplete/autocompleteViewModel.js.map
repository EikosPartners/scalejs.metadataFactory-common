{"version":3,"sources":["../../../src/input/autocomplete/autocompleteViewModel.js"],"names":["autocompleteViewModel","node","inputViewModel","context","dataSourceEndpoint","keyMap","options","unique","inputValue","subs","mapItem","itemMapper","autocompleteSource","values","sourceArray","validations","computedSource","autocompleteSourceDef","console","warn","cloneDeep","mapAutocompleteSource","source","map","src","value","label","getAutocompleteSource","ajax","error","data","dataKey","mappedData","d","retVal","textKey","valueKey","Array","isArray","k","join","delimiter","id","uniqBy","item","filter","Boolean","SearchResults","getAutocompleteSourceFromContext","toArray","fromArray","getValue","text","original","push","extend","deferred","addNew","autocomplete","message","params","subscribe","oldValue","remove","newValue","deleteFlag","deleted","read","selectedItems","difference","newSource","differenceBy","write","newValues","mappedChildNodes","dispose"],"mappings":"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","file":"autocompleteViewModel.js","sourcesContent":["import { observableArray, computed } from 'knockout';\nimport { evaluate } from 'scalejs.expression-jsep';\nimport { has } from 'scalejs';\nimport dataservice from 'dataservice';\nimport _ from 'lodash';\n\n\n// TODO: Refactor multi-input functionality out or to its own viewmodel\n\nexport default function autocompleteViewModel(node, inputViewModel) {\n    const context = this,\n        dataSourceEndpoint = node.dataSourceEndpoint,\n        keyMap = node.keyMap || {},\n        options = node.options || {},\n        unique = options.unique,\n        // inputViewModel\n        inputValue = inputViewModel.inputValue,\n        subs = inputViewModel.subs,\n        mapItem = inputViewModel.mapItem,\n        itemMapper = mapItem(keyMap),\n        // todo: just use values\n        autocompleteSource = inputViewModel.values;\n        // props\n    let sourceArray,\n        validations,\n        computedSource,\n        autocompleteSourceDef;\n\n    if (node.autocompleteSource) {\n        console.warn('[autocomplete] please move the autocompleteSource into options');\n        autocompleteSourceDef = _.cloneDeep(node.autocompleteSource);\n    } else {\n        autocompleteSourceDef = _.cloneDeep(node.options && node.options.autocompleteSource);\n    }\n\n    function mapAutocompleteSource(source) {\n        return source.map((src) => {\n            if (typeof src === 'string') {\n                return {\n                    value: src,\n                    label: src\n                };\n            }\n            return src;\n        });\n    }\n\n    function getAutocompleteSource() {\n        dataservice.ajax(dataSourceEndpoint, (error, data) => {\n            if (error) {\n                console.error('Data retrieval failure', error);\n                return;\n            }\n            if (keyMap.dataKey) {\n                sourceArray = data[keyMap.dataKey];\n                // todo: update to use mapItem\n                const mappedData = data[keyMap.dataKey].map((d) => {\n                    const retVal = keyMap.textKey && keyMap.valueKey ?\n                    {\n                        label: (Array.isArray(keyMap.textKey)\n                            ? keyMap.textKey\n                            : [keyMap.textKey]).map(k => d[k])\n                            .join(keyMap.delimiter || ' / '),\n                        value: d[keyMap.valueKey]\n                    }\n                    : d[node.id]; // todo: remove this and add mapping!\n                    return retVal;\n                });\n                autocompleteSource(\n                    mapAutocompleteSource(_.uniqBy(mappedData, (item) => {\n                        let retVal = '';\n                        if (item && has(item, 'value')) {\n                            retVal = item.value;\n                        }\n                        return retVal;\n                    }).filter(Boolean))); // remove empty values\n            } else {\n                sourceArray = data.SearchResults;\n                autocompleteSource(mapAutocompleteSource(data.SearchResults));\n            }\n        });\n    }\n\n    function getAutocompleteSourceFromContext() {\n        let source = _.toArray(evaluate(autocompleteSourceDef.fromArray || [], context.getValue));\n\n        // storing source array before any mapping\n        sourceArray = source;\n        if (Array.isArray(source)) {\n            autocompleteSource(\n                _.uniqBy(\n                    source\n                        .map(itemMapper)\n                        // todo: remove additional mapping - using binding options\n                        .map((item) => {\n                            return {\n                                label: item.text,\n                                value: item.value,\n                                original: item.original\n                            };\n                        }),\n                    (item) => {\n                        return item.value;\n                    }\n                )\n            );\n        }\n    }\n\n    // function setReadonly(bool) {\n    //     readonly(bool);\n    // }\n\n    if (dataSourceEndpoint) {\n        subs.push(computed(getAutocompleteSource));\n    }\n\n    if (Array.isArray(autocompleteSourceDef)) {\n        sourceArray = autocompleteSourceDef;\n        autocompleteSource(mapAutocompleteSource(autocompleteSourceDef));\n    }\n\n    if (autocompleteSourceDef && !Array.isArray(autocompleteSourceDef)) {\n        subs.push(computed(getAutocompleteSourceFromContext).extend({ deferred: true }));\n    }\n\n    if (!options.addNew) {\n        validations = _.cloneDeep(options.validations) || {};\n        if (!validations || !validations.autocomplete) {\n            validations.autocomplete = {\n                message: 'Please choose a valid selection from the options.',\n                params: autocompleteSource\n            };\n        } else {\n            validations.autocomplete = {\n                message: validations.autocomplete.message || 'Please choose a valid selection from the options.',\n                params: autocompleteSource\n            };\n        }\n    }\n\n    if (unique) {\n        inputValue.subscribe((oldValue) => {\n            context.unique[node.id].remove(oldValue);\n        }, null, 'beforeChange');\n        inputValue.subscribe((newValue) => {\n            if (context.deleteFlag && context.deleteFlag()) { return; }\n            context.unique[node.id].push(newValue);\n        });\n\n        if (context.deleteFlag) {\n            context.deleteFlag.subscribe((deleted) => {\n                if (deleted) {\n                    context.unique[node.id].remove(inputValue());\n                }\n            });\n        }\n\n        computedSource = computed({\n            read: function () {\n                let selectedItems = _.difference(context.unique[node.id](), [inputValue()]).map((item) => {\n                        return {\n                        value: item\n                    };\n                    }),\n                    newSource = _.differenceBy(autocompleteSource(), selectedItems, 'value');\n                return newSource;\n            },\n            write: function (newValues) {\n                autocompleteSource(newValues);\n            }\n        }).extend({ deferred: true });\n    }\n\n    // console.log('Autocomplete source array:', sourceArray);\n\n    return {\n        autocompleteSource: unique ? computedSource : autocompleteSource,\n        validations,\n        mappedChildNodes: observableArray(), // todo: still need?\n        // setReadonly: setReadonly,\n        dispose: () => {\n            if (unique) {\n                context.unique[node.id].remove(inputValue());\n            }\n        }\n    };\n}"]}