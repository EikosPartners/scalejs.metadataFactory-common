{"version":3,"sources":["../../../src/input/autocomplete/autocompleteViewModel.js"],"names":["autocompleteViewModel","node","inputViewModel","context","dataSourceEndpoint","keyMap","options","unique","inputValue","subs","mapItem","itemMapper","autocompleteSource","values","sourceArray","validations","computedSource","autocompleteSourceDef","console","warn","_","cloneDeep","mapAutocompleteSource","source","map","src","value","label","getAutocompleteSource","dataservice","ajax","error","data","dataKey","mappedData","d","retVal","textKey","valueKey","Array","isArray","k","join","delimiter","id","uniqBy","item","filter","Boolean","SearchResults","getAutocompleteSourceFromContext","toArray","fromArray","getValue","text","original","push","extend","deferred","addNew","autocomplete","message","params","subscribe","oldValue","remove","newValue","deleteFlag","deleted","read","selectedItems","difference","newSource","differenceBy","write","newValues","mappedChildNodes","dispose"],"mappings":"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","file":"autocompleteViewModel.js","sourcesContent":["import { observableArray, computed } from 'knockout';\nimport { evaluate } from 'scalejs.expression-jsep';\nimport { has } from 'scalejs';\nimport dataservice from 'dataservice';\nimport _ from 'lodash';\n\n\n// TODO: Refactor multi-input functionality out or to its own viewmodel\n\nexport default function autocompleteViewModel(node, inputViewModel) {\n    const context = this,\n        dataSourceEndpoint = node.dataSourceEndpoint,\n        keyMap = node.keyMap || {},\n        options = node.options || {},\n        unique = options.unique,\n        // inputViewModel\n        inputValue = inputViewModel.inputValue,\n        subs = inputViewModel.subs,\n        mapItem = inputViewModel.mapItem,\n        itemMapper = mapItem(keyMap),\n        // todo: just use values\n        autocompleteSource = inputViewModel.values;\n        // props\n    let sourceArray,\n        validations,\n        computedSource,\n        autocompleteSourceDef;\n\n    if (node.autocompleteSource) {\n        console.warn('[autocomplete] please move the autocompleteSource into options');\n        autocompleteSourceDef = _.cloneDeep(node.autocompleteSource);\n    } else {\n        autocompleteSourceDef = _.cloneDeep(node.options && node.options.autocompleteSource);\n    }\n\n    function mapAutocompleteSource(source) {\n        return source.map((src) => {\n            if (typeof src === 'string') {\n                return {\n                    value: src,\n                    label: src\n                };\n            }\n            return src;\n        });\n    }\n\n    function getAutocompleteSource() {\n        dataservice.ajax(dataSourceEndpoint, (error, data) => {\n            if (error) {\n                console.error('Data retrieval failure', error);\n                return;\n            }\n            if (keyMap.dataKey) {\n                sourceArray = data[keyMap.dataKey];\n                // todo: update to use mapItem\n                const mappedData = data[keyMap.dataKey].map((d) => {\n                    const retVal = keyMap.textKey && keyMap.valueKey ?\n                    {\n                        label: (Array.isArray(keyMap.textKey)\n                            ? keyMap.textKey\n                            : [keyMap.textKey]).map(k => d[k])\n                            .join(keyMap.delimiter || ' / '),\n                        value: d[keyMap.valueKey]\n                    }\n                    : d[node.id]; // todo: remove this and add mapping!\n                    return retVal;\n                });\n                autocompleteSource(\n                    mapAutocompleteSource(_.uniqBy(mappedData, (item) => {\n                        let retVal = '';\n                        if (item && has(item, 'value')) {\n                            retVal = item.value;\n                        }\n                        return retVal;\n                    }).filter(Boolean))); // remove empty values\n            } else {\n                sourceArray = data.SearchResults;\n                autocompleteSource(mapAutocompleteSource(data.SearchResults));\n            }\n        });\n    }\n\n    function getAutocompleteSourceFromContext() {\n        let source = _.toArray(evaluate(autocompleteSourceDef.fromArray || [], context.getValue));\n\n        // storing source array before any mapping\n        sourceArray = source;\n        if (Array.isArray(source)) {\n            autocompleteSource(\n                _.uniqBy(\n                    source\n                        .map(itemMapper)\n                        // todo: remove additional mapping - using binding options\n                        .map((item) => {\n                            return {\n                                label: item.text,\n                                value: item.value,\n                                original: item.original\n                            };\n                        }),\n                    (item) => {\n                        return item.value;\n                    }\n                )\n            );\n        }\n    }\n\n    // function setReadonly(bool) {\n    //     readonly(bool);\n    // }\n\n    if (dataSourceEndpoint) {\n        subs.push(computed(getAutocompleteSource));\n    }\n\n    if (Array.isArray(autocompleteSourceDef)) {\n        sourceArray = autocompleteSourceDef;\n        autocompleteSource(mapAutocompleteSource(autocompleteSourceDef));\n    }\n\n    if (autocompleteSourceDef && !Array.isArray(autocompleteSourceDef)) {\n        subs.push(computed(getAutocompleteSourceFromContext).extend({ deferred: true }));\n    }\n\n    if (!options.addNew) {\n        validations = _.cloneDeep(options.validations) || {};\n        if (!validations || !validations.autocomplete) {\n            validations.autocomplete = {\n                message: 'Please choose a valid selection from the options.',\n                params: autocompleteSource\n            };\n        } else {\n            validations.autocomplete = {\n                message: validations.autocomplete.message || 'Please choose a valid selection from the options.',\n                params: autocompleteSource\n            };\n        }\n    }\n\n    if (unique) {\n        inputValue.subscribe((oldValue) => {\n            context.unique[node.id].remove(oldValue);\n        }, null, 'beforeChange');\n        inputValue.subscribe((newValue) => {\n            if (context.deleteFlag && context.deleteFlag()) { return; }\n            context.unique[node.id].push(newValue);\n        });\n\n        if (context.deleteFlag) {\n            context.deleteFlag.subscribe((deleted) => {\n                if (deleted) {\n                    context.unique[node.id].remove(inputValue());\n                }\n            });\n        }\n\n        computedSource = computed({\n            read: function () {\n                let selectedItems = _.difference(context.unique[node.id](), [inputValue()]).map((item) => {\n                        return {\n                        value: item\n                    };\n                    }),\n                    newSource = _.differenceBy(autocompleteSource(), selectedItems, 'value');\n                return newSource;\n            },\n            write: function (newValues) {\n                autocompleteSource(newValues);\n            }\n        }).extend({ deferred: true });\n    }\n\n    // console.log('Autocomplete source array:', sourceArray);\n\n    return {\n        autocompleteSource: unique ? computedSource : autocompleteSource,\n        validations,\n        mappedChildNodes: observableArray(), // todo: still need?\n        // setReadonly: setReadonly,\n        dispose: () => {\n            if (unique) {\n                context.unique[node.id].remove(inputValue());\n            }\n        }\n    };\n}"]}