{"version":3,"sources":["../../../src/input/select/selectViewModel.js"],"names":["selectViewModel","node","inputViewModel","context","options","values","inputValue","mapItem","format","subs","addBlank","currentFilter","computedValues","console","warn","arrayHasValue","valuesArr","valueOrObjectToCheck","valueToCheck","some","value","unshiftToValues","hasValue","unshift","text","setValuesFromOptionsArray","concat","slice","map","val","setValuesFromOptionsObject","push","peek","newValues","toArray","fromArray","getValue","filter","item","length","extend","deferred","setValue","data","hasOwnProperty","filterValues","valuesToKeep","isModified","valueHasMutated","Array","isArray","read","v","indexOf","write"],"mappings":"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","file":"selectViewModel.js","sourcesContent":["import { observable, observableArray, computed } from 'knockout';    \nimport { evaluate } from 'scalejs.expression-jsep';\nimport { has, get, is } from 'scalejs';\nimport _ from 'lodash';\n\n    /**\n     *  select is a type of input that lets the \n     *  user select the value from dropdown options\n     * \n     * @module input-select\n     * \n     * @param {object} node\n     *  The configuration specs for the component.\n     * @param {string} node.options\n     *  Options specific to this component\n     * @param {bool} [node.options.addBlank=true] \n     *  Whether or not to add a blank to the beginning of the select options\n     * @param {object|array} node.options.values\n     *  Specifies either an array of values to use or an object describing the values\n     * @param {string} node.options.values.fromArray\n     *  A string to be evaluated that will be used to map the values\n     * @param {string|array} node.options.values.textKey\n     *  A string or array which refers to the text key (i.e. the label) for the options\n     * @param {string} node.options.values.valueKey\n     *  A string which referes to the value key for the options\n     * @param {string} [node.options.values.delimeter=' / ']\n     *  A delimeter for the label if the textKey is an array\n     * @param {string} [node.options.values.textFormatter]\n     *  The name of a function to format the label for the option (i.e. dateFormatter)\n     *  \n     */\n    export default function selectViewModel(node, inputViewModel) {\n        var context = this,\n            options = node.options || { values: [] },\n            // inputViewModel\n            inputValue = inputViewModel.inputValue,            \n            mapItem = inputViewModel.mapItem,\n            format = inputViewModel.format,\n            subs = inputViewModel.subs,\n            values = inputViewModel.values,\n            // props            \n            addBlank = !has(options.addBlank) || options.addBlank,\n            currentFilter = observable(),\n            computedValues;\n\n        if(!options.values) {\n            console.warn('select input type being used without values');\n            options.values = [];\n        }\n                \n        /** \n         * Helper function to check if the array has the value\n         * \n         * @param {array}   valuesArr   Array to check for value\n         * @param           value       The value to check in array\n         */    \n        function arrayHasValue(valuesArr, valueOrObjectToCheck) {\n            var valueToCheck = get(valueOrObjectToCheck, 'value', valueOrObjectToCheck);\n            return valuesArr.some(function(value) {\n                return get(value, 'value', value) === valueToCheck;\n            });\n        }\n          \n        /** \n         * Helper function to takes valuesArr and a value.\n         * If the array does not contain the value, it unshifts it\n         * \n         * @param {array}   valuesArr   Array to check for value\n         * @param           value       The value to unshift if not found\n         */       \n        function unshiftToValues(valuesArr, value) {\n            var hasValue = arrayHasValue(valuesArr, value);\n\n            if (options.unshiftToValues && !hasValue && has(value) && value != '') {\n                valuesArr.unshift({\n                    text: format(value),\n                    value: value\n                });\n            }\n            return valuesArr;\n        }\n        \n        /** \n         * Sets the values if the options.values is an array.\n         * Maps any string values to { text, value }\n         */  \n        function setValuesFromOptionsArray() {\n            values((addBlank ? [''] : []).concat(options.values.slice()).map(function(val) {\n                return is(val, 'string') ? { text: val, value: val } : val;\n            }));         \n        }\n        \n        /** \n         * Sets the values if the options.values is an object and options.values.fromArray exists.\n         * fromArray is an expression which is evaluated to retrieve the values from context\n         */ \n        function setValuesFromOptionsObject() {\n            // create a sub to subscribe to changes in values\n            subs.push(computed(function () {\n                var value = inputValue.peek(), \n                    newValues = (_.toArray(evaluate(options.values.fromArray, context.getValue) || []))\n                        .filter(function(item) {\n                            return has(item);\n                        }).map(mapItem(options.values));\n\n                newValues = (addBlank || newValues.length === 0 ? [{ text: '', value: ''}] : []).concat(newValues);\n\n                values(unshiftToValues(newValues, value));\n            }).extend({ deferred: true }));\n        }\n                      \n        /** \n         * setValue is Utilized by the form to set the value of the input after initialization\n         * If the value is not already in the values array, it will be unshifted\n         * \n         * @param {object|value}    data    Either an object with a value or the value to be set\n         */    \n        function setValue(data) {\n            var value = is(data, 'object') && data.hasOwnProperty('value') ? data.value : data;             \n            values(unshiftToValues(values(), value));\n            inputValue(value);\n        }   \n        \n        /** \n         * Function which is utilized by rules engine\n         * Sets the currentFilter observable\n         * This will make the computedValues return only the valuesToKeep\n         * \n         * @param {array}   valuesToKeep    Array of values that will kept in the filter\n         */    \n        function filterValues(valuesToKeep) {\n          currentFilter(valuesToKeep);\n          // changing the currentFilter can change the values\n          // this in turn, changing the inputValue. But for some reason, its not enough to trigger bindings.\n          // manually provoke a change to isModified, so validation bindings get re-evaled.\n          inputValue.isModified.valueHasMutated();\n        }\n        \n        /**\n         * Initialize the values observable either with array or with object\n         */\n        if (Array.isArray(options.values)) { setValuesFromOptionsArray(); }\n        if (options.values.fromArray) { setValuesFromOptionsObject(); }        \n        \n        /**\n         * If currentFilter is defined, return only values which match\n         */\n        computedValues = computed({\n            read: function () {\n                if(!currentFilter()) {\n                    return values();\n                }\n                return values().filter(function (v) {\n                    var value = v.value; // || v; //we used to expect { value: ''} or '', now we always do mapping first\n                    return currentFilter().indexOf(value) !== -1;\n                });\n            },\n            write: function (newValues) {\n                values(newValues);\n            }\n        });\n        \n        return {\n            values: computedValues,\n            setValue: setValue,\n            filterValues: filterValues            \n        }\n    };\n\n"]}