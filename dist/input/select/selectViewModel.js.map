{"version":3,"sources":["../../../src/input/select/selectViewModel.js"],"names":["selectViewModel","node","inputViewModel","context","options","values","inputValue","mapItem","format","subs","addBlank","currentFilter","computedValues","console","warn","arrayHasValue","valuesArr","valueOrObjectToCheck","valueToCheck","some","value","unshiftToValues","hasValue","unshift","text","setValuesFromOptionsArray","concat","slice","map","val","setValuesFromOptionsObject","push","peek","newValues","toArray","fromArray","getValue","filter","item","length","extend","deferred","setValue","data","hasOwnProperty","call","filterValues","valuesToKeep","isModified","valueHasMutated","Array","isArray","read","v","indexOf","write"],"mappings":"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","file":"selectViewModel.js","sourcesContent":["import { observable, computed } from 'knockout';\r\nimport { evaluate } from 'scalejs.expression-jsep';\r\nimport { has, get, is } from 'scalejs';\r\nimport _ from 'lodash';\r\n\r\n/**\r\n *  select is a type of input that lets the\r\n *  user select the value from dropdown options\r\n *\r\n * @module input-select\r\n *\r\n * @param {object} node\r\n *  The configuration specs for the component.\r\n * @param {string} node.options\r\n *  Options specific to this component\r\n * @param {bool} [node.options.addBlank=true]\r\n *  Whether or not to add a blank to the beginning of the select options\r\n * @param {object|array} node.options.values\r\n *  Specifies either an array of values to use or an object describing the values\r\n * @param {string} node.options.values.fromArray\r\n *  A string to be evaluated that will be used to map the values\r\n * @param {string|array} node.options.values.textKey\r\n *  A string or array which refers to the text key (i.e. the label) for the options\r\n * @param {string} node.options.values.valueKey\r\n *  A string which referes to the value key for the options\r\n * @param {string} [node.options.values.delimeter=' / ']\r\n *  A delimeter for the label if the textKey is an array\r\n * @param {string} [node.options.values.textFormatter]\r\n *  The name of a function to format the label for the option (i.e. dateFormatter)\r\n *\r\n */\r\nexport default function selectViewModel(node, inputViewModel) {\r\n    const context = this,\r\n        options = node.options || { values: [] },\r\n        // inputViewModel\r\n        inputValue = inputViewModel.inputValue,\r\n        mapItem = inputViewModel.mapItem,\r\n        format = inputViewModel.format,\r\n        subs = inputViewModel.subs,\r\n        values = inputViewModel.values,\r\n        // props\r\n        addBlank = !has(options.addBlank) || options.addBlank,\r\n        currentFilter = observable();\r\n    let computedValues = {};\r\n\r\n    if (!options.values) {\r\n        console.warn('select input type being used without values');\r\n        options.values = [];\r\n    }\r\n\r\n    /**\r\n     * Helper function to check if the array has the value\r\n     *\r\n     * @param {array}   valuesArr   Array to check for value\r\n     * @param           value       The value to check in array\r\n     */\r\n    function arrayHasValue(valuesArr, valueOrObjectToCheck) {\r\n        const valueToCheck = get(valueOrObjectToCheck, 'value', valueOrObjectToCheck);\r\n        return valuesArr.some(value => get(value, 'value', value) === valueToCheck);\r\n    }\r\n\r\n    /**\r\n     * Helper function to takes valuesArr and a value.\r\n     * If the array does not contain the value, it unshifts it\r\n     *\r\n     * @param {array}   valuesArr   Array to check for value\r\n     * @param           value       The value to unshift if not found\r\n     */\r\n    function unshiftToValues(valuesArr, value) {\r\n        const hasValue = arrayHasValue(valuesArr, value);\r\n\r\n        if (options.unshiftToValues && !hasValue && has(value) && value !== '') {\r\n            valuesArr.unshift({\r\n                text: format(value),\r\n                value\r\n            });\r\n        }\r\n        return valuesArr;\r\n    }\r\n\r\n    /**\r\n     * Sets the values if the options.values is an array.\r\n     * Maps any string values to { text, value }\r\n     */\r\n    function setValuesFromOptionsArray() {\r\n        values((addBlank ? [''] : []).concat(options.values.slice()).map(val => (\r\n            is(val, 'string') ? { text: val, value: val } : val\r\n        )));\r\n    }\r\n\r\n    /**\r\n     * Sets the values if the options.values is an object and options.values.fromArray exists.\r\n     * fromArray is an expression which is evaluated to retrieve the values from context\r\n     */\r\n    function setValuesFromOptionsObject() {\r\n        // create a sub to subscribe to changes in values\r\n        subs.push(computed(() => {\r\n            const value = inputValue.peek();\r\n            let newValues = (_.toArray(evaluate(options.values.fromArray, context.getValue) || []))\r\n                    .filter(item => has(item))\r\n                    .map(mapItem(options.values));\r\n\r\n            newValues = (addBlank || newValues.length === 0 ? [{ text: '', value: '' }] : []).concat(newValues);\r\n\r\n            values(unshiftToValues(newValues, value));\r\n        }).extend({ deferred: true }));\r\n    }\r\n\r\n    /**\r\n     * setValue is Utilized by the form to set the value of the input after initialization\r\n     * If the value is not already in the values array, it will be unshifted\r\n     *\r\n     * @param {object|value}    data    Either an object with a value or the value to be set\r\n     */\r\n    function setValue(data) {\r\n        const value = is(data, 'object') &&\r\n            {}.hasOwnProperty.call(data, 'value') ? data.value : data;\r\n        values(unshiftToValues(values(), value));\r\n        inputValue(value);\r\n    }\r\n\r\n    /**\r\n     * Function which is utilized by rules engine\r\n     * Sets the currentFilter observable\r\n     * This will make the computedValues return only the valuesToKeep\r\n     *\r\n     * @param {array}   valuesToKeep    Array of values that will kept in the filter\r\n     */\r\n    function filterValues(valuesToKeep) {\r\n        currentFilter(valuesToKeep);\r\n        // changing the currentFilter can change the values\r\n        // this in turn, changing the inputValue. But for some reason,\r\n        // its not enough to trigger bindings.\r\n        // manually provoke a change to isModified, so validation bindings get re-evaled.\r\n        inputValue.isModified.valueHasMutated();\r\n    }\r\n\r\n    /**\r\n     * Initialize the values observable either with array or with object\r\n     */\r\n    if (Array.isArray(options.values)) { setValuesFromOptionsArray(); }\r\n    if (options.values.fromArray) { setValuesFromOptionsObject(); }\r\n\r\n    /**\r\n     * If currentFilter is defined, return only values which match\r\n     */\r\n    computedValues = computed({\r\n        read: function () {\r\n            if (!currentFilter()) {\r\n                return values();\r\n            }\r\n            return values().filter((v) => {\r\n                // || v; //we used to expect { value: ''} or '', now we always do mapping first\r\n                const value = v.value;\r\n                return currentFilter().indexOf(value) !== -1;\r\n            });\r\n        },\r\n        write: function (newValues) {\r\n            values(newValues);\r\n        }\r\n    });\r\n\r\n    return {\r\n        values: computedValues,\r\n        setValue,\r\n        filterValues\r\n    };\r\n}"]}