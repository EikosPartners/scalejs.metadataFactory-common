{"version":3,"sources":["../../src/action/actionViewModel.js"],"names":["actionViewModel","node","registeredActions","originalJson","context","options","text","validate","actionType","actions","mergedActions","actionFunc","bind","isShown","disabled","enableUpdates","subs","disabledComputed","action","args","console","error","successCallback","actionNode","onlyIf","only","identifier","results","getValue","immediate","delay","setTimeout","push","id","data","Object","keys","forEach","key","disabledExpression","extend","deferred","subscribe","val","dispose","sub"],"mappings":"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","file":"actionViewModel.js","sourcesContent":["import { notify, receive } from 'scalejs.messagebus';\r\nimport { observable, computed } from 'knockout';\r\nimport { merge, has, get } from 'scalejs';\r\nimport { extend, cloneDeep } from 'lodash';\r\nimport { evaluate } from 'scalejs.expression-jsep';\r\n\r\nimport { getRegisteredActions } from './actionModule';\r\n\r\n/** Action: a component to create an action\r\n * @module action\r\n *\r\n * @param {object} node\r\n *  The configuration object for the module\r\n * @param {string} node.type='action'\r\n *  The type of the node is action\r\n * @param {string} node.actionType\r\n *  The type of action to create\r\n * @param {string} node.text\r\n *  The text to display on the button\r\n * @param {boolean} node.immediate\r\n *  Boolean to determine whether to run the action immediately or not\r\n * @param {number} node.delay\r\n *  How long to delay the action in milliseconds\r\n * @param {string} node.validate\r\n *  The id of an element to validate\r\n * @param {boolean|string} [node.rendered=true]\r\n *  Boolean or expression to render the action (or not)\r\n * @param {object} node.options\r\n *  The options pertaining to your specific actionType\r\n * @param {boolean|string} node.options.disabled\r\n *  Boolean or expression to disable the button or not\r\n */\r\nexport default function actionViewModel(node) {\r\n    const registeredActions = getRegisteredActions(),\r\n        originalJson = cloneDeep(node),\r\n        context = this || {},\r\n        options = node.options || {},\r\n        text = node.text || options.text, // TODO: Why are we checking options?\r\n        validate = node.validate,\r\n        actionType = node.actionType,\r\n        actions = {},\r\n        mergedActions = extend(actions, registeredActions),\r\n        actionFunc = (mergedActions[actionType] && mergedActions[actionType].bind(context)) || null,\r\n        isShown = observable(true),\r\n        disabled = observable(has(options.disabled) ? options.disabled : false),\r\n        enableUpdates = options.enableUpdates,\r\n        subs = [];\r\n    \r\n    let disabledComputed = null;\r\n\r\n    function action(args) {\r\n        if (!actionFunc) {\r\n            console.error('actionType is not defined', node);\r\n            return;\r\n        }\r\n\r\n        if (validate) {\r\n            notify(validate, {\r\n                successCallback: function () {\r\n                    actionFunc(options, args);\r\n                },\r\n                actionNode: cloneDeep(originalJson),\r\n                context: context\r\n            });\r\n        } else if (node.onlyIf) {\r\n            const only = evaluate(node.onlyIf, (identifier) => {\r\n                // worried about collisions, we should keep the getValue function consistent as possible\r\n                if (identifier === 'results') {\r\n                    return options.results;\r\n                }\r\n                if (identifier === 'options') {\r\n                    return options;\r\n                }\r\n                return context.getValue(identifier);\r\n            });\r\n            if (only) {\r\n                actionFunc(options, args);\r\n            }\r\n        } else {\r\n            actionFunc(options, args);\r\n        }\r\n    }\r\n\r\n    if (node.immediate) {\r\n        if (has(node.delay)) {\r\n            setTimeout(() => {\r\n                action();\r\n            }, node.delay);\r\n            return;\r\n        }\r\n        action();\r\n        return;\r\n    }\r\n\r\n    if (enableUpdates) {\r\n        subs.push(receive(`${node.id}.update`, (data) => {\r\n            Object.keys(data).forEach((key) => {\r\n                if (key === 'disabled') { disabled(data[key]); }\r\n            });\r\n        }));\r\n    }\r\n\r\n    if (node.disabledExpression) {\r\n        disabledComputed = computed(() => evaluate(node.disabledExpression, context.getValue))\r\n            .extend({ deferred: true });\r\n        disabled(disabledComputed());\r\n        disabledComputed.subscribe((val) => {\r\n            disabled(val);\r\n        });\r\n        subs.push(disabledComputed);\r\n    }\r\n\r\n    return merge(node, {\r\n        isShown: isShown,\r\n        action: action,\r\n        text: text,\r\n        actionType: actionType,\r\n        options: options,\r\n        disabled: disabled,\r\n        context: context,\r\n        dispose: function () {\r\n            subs.forEach((sub) => {\r\n                sub.dispose();\r\n            });\r\n        }\r\n    });\r\n}"]}