{"version":3,"sources":["../../src/adapter/adapterViewModel.js"],"names":["adapterViewModel","node","dictionary","data","context","metadata","children","parentContext","getValue","id","mappedChildNodes","subs","plugins","call","contextPlugins","dataSyncSubscription","updated","forEach","plugin","type","createDictionary","nodes","dict","peek","n","syncDataDictionary","Object","keys","rendered","trackIfHidden","updateData","newData","dispose","fetchData","dataSourceEndpointArray","Array","isArray","dataSourceEndpoint","dataObject","persist","count","e","endpoint","uri","console","warn","target","actionType","options","action","callback","error","results","resultsByKey","keyMapArray","keyMap","newDataObject","resultsKey","dataKey","storeKey","setValue","length","dictNode","dataValue","keepContextData","lazy","valueHasMutated","push","key","sub"],"mappings":";;;;;kBA6EwBA,gB;;AA7ExB;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;AAEA;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiEe,SAASA,gBAAT,CAA0BC,IAA1B,EAAgC;AAC3C,QAAMC,aAAa,0BAAW,EAAX,CAAnB;AAAA,QAAmC;AAC/BC,WAAO,0BAAW,EAAX,CADX;AAAA,QAC2B;AACvBC,cAAU;AACNC,kBAAUJ,KAAKK,QADT;AAENC,uBAAe,IAFT;AAGNC,kBAAUA,QAHJ;AAINN,oBAAYA,UAJN;AAKNC,cAAMA,IALA;AAMNM,YAAIR,KAAKQ;AANH,KAFd;AAAA,QAUIC,mBAAmB,gCAVvB;AAAA,QAWIC,OAAO,EAXX;AAAA,QAYIC,UAAUX,KAAKW,OAAL,GAAe,0BAAiBC,IAAjB,CAAsBT,OAAtB,EAA+BH,KAAKW,OAApC,CAAf,GAA8D,EAZ5E;AAAA,QAaIE,iBAAiB,EAbrB;;AAeA,QAAIC,6BAAJ;AAAA,QACIC,UAAU,KADd;;AAGAJ,YAAQK,OAAR,CAAgB,UAACC,MAAD,EAAY;AACxBJ,uBAAeI,OAAOC,IAAtB,IAA8BD,MAA9B;AACH,KAFD;;AAIA;AACA,aAASE,gBAAT,CAA0BC,KAA1B,EAAiC;AAC7B,YAAMC,OAAOpB,WAAWqB,IAAX,EAAb;AACAF,cAAMJ,OAAN,CAAc,UAACO,CAAD,EAAO;AACjB;AACA,gBAAIA,EAAEf,EAAF,IAAQ,CAACa,KAAKE,EAAEf,EAAP,CAAb,EAAyB;AACrBa,qBAAKE,EAAEf,EAAP,IAAae,CAAb;AACAR,0BAAU,IAAV;AACH;AACD;AACA,gBAAI,CAACQ,EAAEhB,QAAP,EAAiB;AACbY,iCAAiB,sBAAOI,EAAEd,gBAAT,KAA8B,EAA/C;AACH;AACJ,SAVD;AAWH;;AAED;AACA,aAASe,kBAAT,GAA8B;AAC1BV,+BAAuB,wBAAS,YAAM;AAClC,gBAAMO,OAAOpB,YAAb;AACAwB,mBAAOC,IAAP,CAAYL,IAAZ,EAAkBL,OAAlB,CAA0B,UAACR,EAAD,EAAQ;AAC9B,oBAAIa,KAAKb,EAAL,EAASmB,QAAb,EAAuB;AACnB,wBAAIN,KAAKb,EAAL,EAASmB,QAAT,MAAuBN,KAAKb,EAAL,EAASD,QAApC,EAA8C;AAC1CL,+BAAOM,EAAP,IAAaa,KAAKb,EAAL,EAASD,QAAT,EAAb;AACH,qBAFD,MAEO,IAAI,CAACc,KAAKb,EAAL,EAASmB,QAAT,EAAL,EAA0B;AAC7B,4BAAIN,KAAKb,EAAL,EAASoB,aAAb,EAA4B;AACxB1B,mCAAOM,EAAP,IAAaa,KAAKb,EAAL,EAASD,QAAT,EAAb;AACH,yBAFD,MAEO;AACH,mCAAOL,OAAOM,EAAP,CAAP;AACH;AACJ;AACJ;AACJ,aAZD;AAaH,SAfsB,CAAvB;AAgBH;;AAED;AACA,aAASqB,UAAT,CAAoBC,OAApB,EAA6B;AACzBhB,gCAAwBA,qBAAqBiB,OAArB,EAAxB;AACA7B,aAAK4B,OAAL;AACAN;AACH;;AAED;AACA,aAASQ,SAAT,GAAqB;AACjB,YAAMC,0BAA0BC,MAAMC,OAAN,CAAcnC,KAAKoC,kBAAnB,IAC1BpC,KAAKoC,kBADqB,GACA,CAACpC,KAAKoC,kBAAN,CADhC;AAAA,YAEIC,aAAarC,KAAKsC,OAAL,GAAepC,MAAf,GAAwB,EAFzC;AAGA,YAAIqC,QAAQ,CAAZ;;AAEAN,gCAAwBjB,OAAxB,CAAgC,UAACwB,CAAD,EAAO;AACnC,gBAAIC,WAAWD,CAAf;AACA,gBAAIC,SAASC,GAAb,EAAkB;AACdC,wBAAQC,IAAR,CAAa,+FAAb;AACAH,2BAAW,qBAAMA,QAAN,EAAgB;AACvBI,4BAAQJ;AADe,iBAAhB,CAAX;AAGA,uBAAOA,SAASC,GAAhB;AACH;;AAED,qCAAgB9B,IAAhB,CAAqBT,OAArB,EAA8B;AAC1Be,sBAAM,QADoB;AAE1B4B,4BAAY,MAFc;AAG1BC,yBAASN;AAHiB,aAA9B,EAIGO,MAJH,CAIU;AACNC,0BAAU,kBAAUC,KAAV,EAAiBC,OAAjB,EAA0B;AAChC,wBAAIC,qBAAJ;AAAA,wBACIC,cAAcZ,SAASa,MAAT,IAAmB,CAAC,EAAD,CADrC;AAAA,wBAEIC,gBAAgB,EAFpB;;AAIAhB,6BAAS,CAAT;;AAEA,wBAAI,CAACL,MAAMC,OAAN,CAAckB,WAAd,CAAL,EAAiC;AAC7BA,sCAAc,CAACA,WAAD,CAAd;AACH;;AAED,wBAAI,CAACH,KAAL,EAAY;AACRG,oCAAYrC,OAAZ,CAAoB,UAACsC,MAAD,EAAY;AAC5BF,2CAAeE,OAAOE,UAAP,GAAoB,mBAAIL,OAAJ,EAAaG,OAAOE,UAApB,CAApB,GAAsDL,OAArE;AACA;AACA,gCAAIG,OAAOG,OAAX,EAAoB;AAChBF,8CAAcD,OAAOG,OAArB,IAAgCL,YAAhC;AACH,6BAFD,MAEO,IAAIE,OAAOI,QAAX,EAAqB;AACxB,kDAAYC,QAAZ,CAAqBL,OAAOI,QAA5B,EAAsCN,YAAtC;AACH,6BAFM,MAEA;AACHG,gDAAgBH,YAAhB;AACH;AACD,gDAAOf,UAAP,EAAmBkB,aAAnB;AACH,yBAXD;AAYH;;AAED,wBAAIhB,UAAUN,wBAAwB2B,MAAtC,EAA8C;AAC1C/B,mCAAWQ,UAAX;AACA,4BAAI,CAAC5B,mBAAmBmD,MAAxB,EAAgC;AAC5BnD,6CAAiB,0BAAiBG,IAAjB,CAAsBT,OAAtB,EAA+BH,KAAKK,QAAL,IAAiB,EAAhD,CAAjB;AACH;AACJ;AACJ;AAjCK,aAJV;AAuCH,SAjDD;AAkDH;;AAED,aAASE,QAAT,CAAkBC,EAAlB,EAAsB;AAClB,YAAMqD,WAAW5D,aAAaO,EAAb,CAAjB;AAAA,YACIsD,YAAY,CAAC5D,UAAU,EAAX,EAAeM,EAAf,CADhB;;AAGA;AACA,YAAIqD,YAAYA,SAAStD,QAAzB,EAAmC;AAAE,mBAAOsD,SAAStD,QAAT,EAAP;AAA6B;;AAElE;AACA,YAAIuD,SAAJ,EAAe;AAAE,mBAAOA,SAAP;AAAmB;;AAEpC,YAAIjD,kBAAkBA,eAAeL,EAAf,CAAtB,EAA0C;AACtC,mBAAOK,eAAeL,EAAf,GAAP;AACH;AACD,eAAOL,QAAQG,aAAR,CAAsBC,QAAtB,CAA+BC,EAA/B,CAAP;AACH;;AAED,QAAIR,KAAK+D,eAAT,EAA0B;AACtB7D,aAAK,sBAAO,KAAKA,IAAZ,KAAqB,EAA1B;AACH;;AAED,QAAI,CAACF,KAAKgE,IAAV,EAAgB;AACZvD,yBAAiB,0BAAiBG,IAAjB,CAAsBT,OAAtB,EAA+BH,KAAKK,QAAL,IAAiB,EAAhD,CAAjB;AACH;;AAED;AACA,4BAAS,YAAM;AACXU,kBAAU,KAAV;AACAI,yBAAiBV,kBAAjB;AACA,YAAIM,OAAJ,EAAa;AACTd,uBAAWgE,eAAX;AACH;AACJ,KAND;;AAQA;AACAzC;;AAEA;AACA,QAAIxB,KAAKoC,kBAAT,EAA6B;AACzBJ;AACH;;AAED;AACAtB,SAAKwD,IAAL,CAAU,uBAAWlE,KAAKQ,EAAhB,eAA8B,UAACuC,OAAD,EAAa;AACjD;AACA,YAAI/C,KAAKoC,kBAAT,EAA6B;AACzBJ,sBAAUe,OAAV;AACH,SAFD,MAEO;AACHtB,mBAAOC,IAAP,CAAYzB,YAAZ,EAA0Be,OAA1B,CAAkC,UAACmD,GAAD,EAAS;AACvClE,6BAAakE,GAAb,EAAkBR,QAAlB,IAA8B1D,aAAakE,GAAb,EAAkBR,QAAlB,CAA2B,EAA3B,CAA9B;AACH,aAFD;AAGH;AACJ,KATS,CAAV;;AAWA,WAAO,qBAAM3D,IAAN,EAAY;AACfS,0BAAkBA,gBADH;AAEfP,cAAMA,IAFS;AAGfW,wBAAgBA,cAHD;AAIfV,iBAASA,OAJM;AAKf4B,iBAAS,mBAAY;AACjBrB,iBAAKM,OAAL,CAAa,UAACoD,GAAD,EAAS;AAClBA,oBAAIrC,OAAJ;AACH,aAFD;AAGH;AATc,KAAZ,CAAP;AAWH","file":"adapterViewModel.js","sourcesContent":["import { observable, observableArray, computed, unwrap } from 'knockout';\nimport { createViewModel, createViewModels } from 'scalejs.metadataFactory';\nimport { receive } from 'scalejs.messagebus';\nimport { extend } from 'lodash';\nimport { get, merge } from 'scalejs';\nimport noticeboard from 'scalejs.noticeboard';\n\n/* TODO:\nIn PJSON, we used readonly, errors, etc. We need a way to do that outside of adapter\ni.e. plugin to adapter context with other components\n*/\n\n/** Adapter: a viewless component which keeps track of child nodes and the data for the nodes\n * @module adapter\n *\n * @param {object} node\n *  The configuration object for the module\n * @param {string} node.type='adapter'\n *  The type of the node is adapter\n * @param {string} node.id\n *  The id for the module\n * @param {boolean} [node.lazy=false]\n *  If the child nodes need to be lazily loaded\n * (e.g. delay creation of children viewmodels until data returns)\n * @param {boolean} [node.persist=false]\n *  If data object should be persisted from one fetch data call to the next (upon refresh)\n * @param {object|Object[]} [node.dataSourceEndpoint]\n *  An object defining the endpoint(s) that makes the ajax calls\n * @param {string} node.dataSourceEndpoint.uri\n *   The uri for the endpoint\n * @param {string} [node.dataSourceEndpoint.url]\n *  The url for the endpoint\n * @param {array|object} [node.dataSourceEndpoint.keyMap]\n *  A mapper object or array of mapper objects to map keys\n * @param {string} [node.dataSourceEndpoint.keyMap.resultsKey]\n *  Map the results from the ajax call with this key\n * @param {string} [node.dataSourceEndpoint.keyMap.dataKey]\n *  Extend the data object with this key\n * @param {string} [node.dataSourceEndpoint.keyMap.storeKey]\n *  Place the resultsByKey inside of the store with this key\n * @param {object} [node.dataSourceEndpoint.options]\n *  Options for the ajax call\n * @param {array} node.children\n *  The json configuration for children nodes which will be mapped\n * to view models and kept track of from the adapter\n * @param {array} [node.plugins]\n *  The json configuration for plugins which will be accessible\n * from getValue function, based upon type\n *\n * @property {array} mappedChildNodes the mapped children nodes\n * @property {observable} data the data retrieved from dataSourceEndpoint and tracked from children\n * @property {object} contextPlugins an object that contains the plugins which have\n * been added to the adapter context\n * @property {context} the context for the adapter (which can be utilized in a custom template)\n * @property {function} dispose the dispose function for all internal subs\n *\n * @example\n * {\n *      \"type\": \"adapter\",\n *      \"id\": \"ADAPTER_ID\",\n *      \"dataSourceEndpoint\": [\n *          {\n *              \"uri\": \"endpoint/uri\",\n *              \"options\": {\n *                  \"type\": \"PUT\"\n *              },\n *              \"keyMap\": {\n *                  \"dataKey\": \"a\",\n *                  \"resultsKey\": \"b\"\n *              }\n *          }\n *      ],\n *      \"children\": [\n *          // children json configuration goes here\n *      ]\n * }\n */\nexport default function adapterViewModel(node) {\n    const dictionary = observable({}), // dictionary of nodes with an id\n        data = observable({}), // data of dictionary contents\n        context = {\n            metadata: node.children,\n            parentContext: this,\n            getValue: getValue,\n            dictionary: dictionary,\n            data: data,\n            id: node.id\n        },\n        mappedChildNodes = observableArray(),\n        subs = [],\n        plugins = node.plugins ? createViewModels.call(context, node.plugins) : [],\n        contextPlugins = {};\n\n    let dataSyncSubscription,\n        updated = false;\n\n    plugins.forEach((plugin) => {\n        contextPlugins[plugin.type] = plugin;\n    });\n\n    // recursive function which parses through nodes and adds nodes with an id to dictionary\n    function createDictionary(nodes) {\n        const dict = dictionary.peek();\n        nodes.forEach((n) => {\n            // add node to dictionary if it isnt there yet\n            if (n.id && !dict[n.id]) {\n                dict[n.id] = n;\n                updated = true;\n            }\n            // add children to dictionary if getValue function is not exposed\n            if (!n.getValue) {\n                createDictionary(unwrap(n.mappedChildNodes) || []);\n            }\n        });\n    }\n\n    // keep the data current if the node value changed with dataSyncDescription\n    function syncDataDictionary() {\n        dataSyncSubscription = computed(() => {\n            const dict = dictionary();\n            Object.keys(dict).forEach((id) => {\n                if (dict[id].rendered) {\n                    if (dict[id].rendered() && dict[id].getValue) {\n                        data()[id] = dict[id].getValue();\n                    } else if (!dict[id].rendered()) {\n                        if (dict[id].trackIfHidden) {\n                            data()[id] = dict[id].getValue();\n                        } else {\n                            delete data()[id];\n                        }\n                    }\n                }\n            });\n        });\n    }\n\n    // pause dataSyncDescription and update the data\n    function updateData(newData) {\n        dataSyncSubscription && dataSyncSubscription.dispose();\n        data(newData);\n        syncDataDictionary();\n    }\n\n    // fetches the data from dataSourceEndpoint(s)\n    function fetchData() {\n        const dataSourceEndpointArray = Array.isArray(node.dataSourceEndpoint)\n            ? node.dataSourceEndpoint : [node.dataSourceEndpoint],\n            dataObject = node.persist ? data() : {};\n        let count = 0;\n\n        dataSourceEndpointArray.forEach((e) => {\n            let endpoint = e;\n            if (endpoint.uri) {\n                console.warn('dataSourceEndpoint expects URI in \"target\". Please update your JSON to reflect the new syntax');\n                endpoint = merge(endpoint, {\n                    target: endpoint\n                });\n                delete endpoint.uri;\n            }\n\n            createViewModel.call(context, {\n                type: 'action',\n                actionType: 'ajax',\n                options: endpoint\n            }).action({\n                callback: function (error, results) {\n                    let resultsByKey,\n                        keyMapArray = endpoint.keyMap || [{}],\n                        newDataObject = {};\n\n                    count += 1;\n\n                    if (!Array.isArray(keyMapArray)) {\n                        keyMapArray = [keyMapArray];\n                    }\n\n                    if (!error) {\n                        keyMapArray.forEach((keyMap) => {\n                            resultsByKey = keyMap.resultsKey ? get(results, keyMap.resultsKey) : results;\n                            // optional: keyMap.dataKey path to extend dataObject on\n                            if (keyMap.dataKey) {\n                                newDataObject[keyMap.dataKey] = resultsByKey;\n                            } else if (keyMap.storeKey) {\n                                noticeboard.setValue(keyMap.storeKey, resultsByKey);\n                            } else {\n                                newDataObject = resultsByKey;\n                            }\n                            extend(dataObject, newDataObject);\n                        });\n                    }\n\n                    if (count === dataSourceEndpointArray.length) {\n                        updateData(dataObject);\n                        if (!mappedChildNodes().length) {\n                            mappedChildNodes(createViewModels.call(context, node.children || []));\n                        }\n                    }\n                }\n            });\n        });\n    }\n\n    function getValue(id) {\n        const dictNode = dictionary()[id],\n            dataValue = (data() || {})[id];\n\n        // the node has been defined so get the value from the node\n        if (dictNode && dictNode.getValue) { return dictNode.getValue(); }\n\n        // data has been defined for the node but the node doesnt exist yet\n        if (dataValue) { return dataValue; }\n\n        if (contextPlugins && contextPlugins[id]) {\n            return contextPlugins[id]();\n        }\n        return context.parentContext.getValue(id);\n    }\n\n    if (node.keepContextData) {\n        data(unwrap(this.data) || {});\n    }\n\n    if (!node.lazy) {\n        mappedChildNodes(createViewModels.call(context, node.children || []));\n    }\n\n    // update dictionary if mappedChildNodes of a node updates\n    computed(() => {\n        updated = false;\n        createDictionary(mappedChildNodes());\n        if (updated) {\n            dictionary.valueHasMutated();\n        }\n    });\n\n    // initialize the data subscription\n    syncDataDictionary();\n\n    // get initial data\n    if (node.dataSourceEndpoint) {\n        fetchData();\n    }\n\n    // listen for 'refresh' event\n    subs.push(receive(`${node.id}.refresh`, (options) => {\n        // console.log('-->', node);\n        if (node.dataSourceEndpoint) {\n            fetchData(options);\n        } else {\n            Object.keys(dictionary()).forEach((key) => {\n                dictionary()[key].setValue && dictionary()[key].setValue('');\n            });\n        }\n    }));\n\n    return merge(node, {\n        mappedChildNodes: mappedChildNodes,\n        data: data,\n        contextPlugins: contextPlugins,\n        context: context,\n        dispose: function () {\n            subs.forEach((sub) => {\n                sub.dispose();\n            });\n        }\n    });\n}"]}