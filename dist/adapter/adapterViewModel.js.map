{"version":3,"sources":["../../src/adapter/adapterViewModel.js"],"names":["adapterViewModel","node","dictionary","data","context","metadata","children","parentContext","getValue","id","mappedChildNodes","updated","subs","dataSyncSubscription","plugins","call","contextPlugins","forEach","plugin","type","createDictionary","nodes","dict","peek","syncDataDictionary","Object","keys","rendered","trackIfHidden","updateData","newData","dispose","fetchData","dataSourceEndpointArray","Array","isArray","dataSourceEndpoint","count","dataObject","persist","endpoint","uri","console","warn","target","action","callback","error","results","resultsByKey","keyMapArray","keyMap","newDataObject","resultsKey","dataKey","storeKey","setValue","length","dataValue","keepContextData","lazy","valueHasMutated","push","options","log","key","sub"],"mappings":"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","file":"adapterViewModel.js","sourcesContent":["import { observable, observableArray, computed, unwrap } from 'knockout';\r\nimport { createViewModel, createViewModels } from 'scalejs.metadataFactory';\r\nimport { receive, notify } from 'scalejs.messagebus';\r\nimport dataservice from 'dataservice';\r\nimport { extend } from 'lodash';\r\nimport { get, merge } from 'scalejs';\r\nimport noticeboard from 'scalejs.noticeboard';\r\n\r\n/* TODO:\r\nIn PJSON, we used readonly, errors, etc. We need a way to do that outside of adapter\r\ni.e. plugin to adapter context with other components\r\n*/\r\n\r\n/** Adapter: a viewless component which keeps track of child nodes and the data for the nodes\r\n * @module adapter\r\n *\r\n * @param {object} node\r\n *  The configuration object for the module\r\n * @param {string} node.type='adapter'\r\n *  The type of the node is adapter\r\n * @param {string} node.id\r\n *  The id for the module\r\n * @param {boolean} [node.lazy=false]\r\n *  If the child nodes need to be lazily loaded (e.g. delay creation of children viewmodels until data returns)\r\n * @param {boolean} [node.persist=false]\r\n *  If data object should be persisted from one fetch data call to the next (upon refresh)\r\n * @param {object|Object[]} [node.dataSourceEndpoint]\r\n *  An object defining the endpoint(s) that makes the ajax calls\r\n * @param {string} node.dataSourceEndpoint.uri\r\n *   The uri for the endpoint\r\n * @param {string} [node.dataSourceEndpoint.url]\r\n *  The url for the endpoint\r\n * @param {array|object} [node.dataSourceEndpoint.keyMap]\r\n *  A mapper object or array of mapper objects to map keys\r\n * @param {string} [node.dataSourceEndpoint.keyMap.resultsKey]\r\n *  Map the results from the ajax call with this key\r\n * @param {string} [node.dataSourceEndpoint.keyMap.dataKey]\r\n *  Extend the data object with this key\r\n * @param {string} [node.dataSourceEndpoint.keyMap.storeKey]\r\n *  Place the resultsByKey inside of the store with this key\r\n * @param {object} [node.dataSourceEndpoint.options]\r\n *  Options for the ajax call\r\n * @param {array} node.children\r\n *  The json configuration for children nodes which will be mapped to view models and kept track of from the adapter\r\n * @param {array} [node.plugins]\r\n *  The json configuration for plugins which will be accessible from getValue function, based upon type\r\n *\r\n * @property {array} mappedChildNodes the mapped children nodes\r\n * @property {observable} data the data retrieved from dataSourceEndpoint and tracked from children\r\n * @property {object} contextPlugins an object that contains the plugins which have been added to the adapter context\r\n * @property {context} the context for the adapter (which can be utilized in a custom template)\r\n * @property {function} dispose the dispose function for all internal subs\r\n *\r\n * @example\r\n * {\r\n *      \"type\": \"adapter\",\r\n *      \"id\": \"ADAPTER_ID\",\r\n *      \"dataSourceEndpoint\": [\r\n *          {\r\n *              \"uri\": \"endpoint/uri\",\r\n *              \"options\": {\r\n *                  \"type\": \"PUT\"\r\n *              },\r\n *              \"keyMap\": {\r\n *                  \"dataKey\": \"a\",\r\n *                  \"resultsKey\": \"b\"\r\n *              }\r\n *          }\r\n *      ],\r\n *      \"children\": [\r\n *          // children json configuration goes here\r\n *      ]\r\n * }\r\n */\r\nexport default function adapterViewModel(node) {\r\n    let dictionary = observable({}), // dictionary of nodes with an id\r\n        data = observable({}), // data of dictionary contents\r\n        context = {\r\n            metadata: node.children,\r\n            parentContext: this,\r\n            getValue: getValue,\r\n            dictionary: dictionary,\r\n            data: data,\r\n            id: node.id\r\n        },\r\n        mappedChildNodes = observableArray(),\r\n        updated = false,\r\n        subs = [],\r\n        dataSyncSubscription,\r\n        plugins = node.plugins ? createViewModels.call(context, node.plugins) : [],\r\n        contextPlugins = {};\r\n\r\n    plugins.forEach(plugin => {\r\n        contextPlugins[plugin.type] = plugin;\r\n    });\r\n\r\n    // recursive function which parses through nodes and adds nodes with an id to dictionary\r\n    function createDictionary(nodes) {\r\n        let dict = dictionary.peek();\r\n        nodes.forEach(node => {\r\n            // add node to dictionary if it isnt there yet\r\n            if (node.id && !dict[node.id]) {\r\n                dict[node.id] = node;\r\n                updated = true;\r\n            }\r\n            // add children to dictionary if getValue function is not exposed\r\n            if (!node.getValue) {\r\n                createDictionary(unwrap(node.mappedChildNodes) || []);\r\n            }\r\n        });\r\n    }\r\n\r\n    // keep the data current if the node value changed with dataSyncDescription\r\n    function syncDataDictionary() {\r\n        dataSyncSubscription = computed(() => {\r\n            let dict = dictionary();\r\n            Object.keys(dict).forEach(id => {\r\n                if (dict[id].rendered) {\r\n                    if (dict[id].rendered() && dict[id].getValue) {\r\n                        data()[id] = dict[id].getValue();\r\n                    } else if (!dict[id].rendered()) {\r\n                        if(dict[id].trackIfHidden) {\r\n                            data()[id] = dict[id].getValue();\r\n                        } else {\r\n                           delete data()[id];\r\n                       } \r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    // pause dataSyncDescription and update the data\r\n    function updateData(newData) {\r\n        dataSyncSubscription && dataSyncSubscription.dispose();\r\n        data(newData);\r\n        syncDataDictionary();\r\n    }\r\n\r\n    // fetches the data from dataSourceEndpoint(s)\r\n    function fetchData() {\r\n        let dataSourceEndpointArray = Array.isArray(node.dataSourceEndpoint)\r\n            ? node.dataSourceEndpoint : [node.dataSourceEndpoint],\r\n            count = 0,\r\n            dataObject = node.persist ? data() : {};\r\n\r\n        dataSourceEndpointArray.forEach(function (endpoint) {\r\n            if (endpoint.uri) {\r\n                console.warn('dataSourceEndpoint expects URI in \"target\". Please update your JSON to reflect the new syntax');\r\n                endpoint = merge(endpoint, {\r\n                    target: endpoint\r\n                });\r\n                delete endpoint.uri;\r\n            }\r\n\r\n            createViewModel.call(context, {\r\n                \"type\": \"action\",\r\n                \"actionType\": \"ajax\",\r\n                \"options\": endpoint\r\n            }).action({\r\n                callback: function (error, results) {\r\n                    let resultsByKey,\r\n                        keyMapArray = endpoint.keyMap || [{}],\r\n                        newDataObject = {};\r\n\r\n                    count++;\r\n                    \r\n                    if (!Array.isArray(keyMapArray)) {\r\n                        keyMapArray = [keyMapArray];\r\n                    }\r\n\r\n                    if (!error) {\r\n                        keyMapArray.forEach(keyMap => {\r\n                            resultsByKey = keyMap.resultsKey ? get(results, keyMap.resultsKey) : results;\r\n                            // optional: keyMap.dataKey path to extend dataObject on\r\n                            if (keyMap.dataKey) {\r\n                                newDataObject[keyMap.dataKey] = resultsByKey;\r\n                            } else if (keyMap.storeKey) {\r\n                                noticeboard.setValue(keyMap.storeKey, resultsByKey);\r\n                            } else {\r\n                                newDataObject = resultsByKey;\r\n                            }\r\n                            extend(dataObject, newDataObject);\r\n                        });\r\n                    }\r\n\r\n                    if (count === dataSourceEndpointArray.length) {\r\n                        updateData(dataObject);\r\n                        if (!mappedChildNodes().length) {\r\n                            mappedChildNodes(createViewModels.call(context, node.children || []));\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n        });\r\n    }\r\n\r\n    function getValue(id) {\r\n        let node = dictionary()[id],\r\n            dataValue = (data() || {})[id];\r\n\r\n        // the node has been defined so get the value from the node\r\n        if (node && node.getValue) { return node.getValue(); }\r\n\r\n        // data has been defined for the node but the node doesnt exist yet\r\n        if (dataValue) { return dataValue; }\r\n\r\n        if (contextPlugins && contextPlugins[id]) {\r\n            return contextPlugins[id]();\r\n        }\r\n        return context.parentContext.getValue(id);\r\n    }\r\n\r\n    if (node.keepContextData) {\r\n        data(unwrap(this.data));\r\n    }\r\n\r\n    if (!node.lazy) {\r\n        mappedChildNodes(createViewModels.call(context, node.children || []));\r\n    }\r\n    \r\n    // update dictionary if mappedChildNodes of a node updates\r\n    computed(() => {\r\n        updated = false;\r\n        createDictionary(mappedChildNodes())\r\n        if (updated) {\r\n            dictionary.valueHasMutated();\r\n        }\r\n    });\r\n\r\n    // initialize the data subscription\r\n    syncDataDictionary();\r\n\r\n    // get initial data\r\n    if (node.dataSourceEndpoint) {\r\n        fetchData();\r\n    }\r\n\r\n    // listen for 'refresh' event\r\n    subs.push(receive(node.id + '.refresh', function (options) {\r\n        console.log('-->', node);\r\n        if (node.dataSourceEndpoint) {\r\n            fetchData(options);\r\n        } else {\r\n            Object.keys(dictionary()).forEach((key) => {\r\n                dictionary()[key].setValue && dictionary()[key].setValue('');\r\n            });\r\n        }\r\n    }));\r\n\r\n    return merge(node, {\r\n        mappedChildNodes: mappedChildNodes,\r\n        data: data,\r\n        contextPlugins: contextPlugins,\r\n        context: context,\r\n        dispose: function () {\r\n            subs.forEach(function (sub) {\r\n                sub.dispose();\r\n            });\r\n        }\r\n    });\r\n};\r\n"]}