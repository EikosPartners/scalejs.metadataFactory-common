{"version":3,"sources":["../../src/adapter/adapterViewModel.js"],"names":[],"mappings":"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","file":"adapterViewModel.js","sourcesContent":["import { observable, observableArray, computed, unwrap } from 'knockout';\nimport { createViewModel, createViewModels } from 'scalejs.metadataFactory';\nimport { receive, notify } from 'scalejs.messagebus';\nimport dataservice from 'dataservice';\nimport { extend } from 'lodash';\nimport { get, merge } from 'scalejs';\n\n/* TODO:\nIn PJSON, we used readonly, errors, etc. We need a way to do that outside of adapter\ni.e. plugin to adapter context with other components\n*/\n\n/** Adapter: a viewless component which keeps track of child nodes and the data for the nodes\n * @module adapter\n *\n * @param {object} node\n *  The configuration object for the module\n * @param {string} node.type='adapter'\n *  The type of the node is adapter\n * @param {string} node.id\n *  The id for the module\n * @param {boolean} [node.lazy=false]\n *  If the child nodes need to be lazily loaded (e.g. delay creation of children viewmodels until data returns)\n * @param {object|Object[]} [node.dataSourceEndpoint]\n *  An object defining the endpoint(s) that makes the ajax calls\n * @param {string} node.dataSourceEndpoint.uri\n *   The uri for the endpoint\n * @param {string} [node.dataSourceEndpoint.url]\n *  The url for the endpoint\n * @param {object} [node.dataSourceEndpoint.keyMap]\n *  A mapper object to map keys\n * @param {string} [node.dataSourceEndpoint.keyMap.resultsKey]\n *  Map the results from the ajax call with this key\n * @param {string} [node.dataSourceEndpoint.keyMap.dataKey]\n *  Extend the data object with this key\n * @param {object} [node.dataSourceEndpoint.options]\n *  Options for the ajax call\n * @param {array} node.children\n *  The json configuration for children nodes which will be mapped to view models and kept track of from the adapter\n * @param {array} [node.plugins]\n *  The json configuration for plugins which will be accessible from getValue function, based upon type\n *\n * @property {array} mappedChildNodes the mapped children nodes\n * @property {observable} data the data retrieved from dataSourceEndpoint and tracked from children\n * @property {object} contextPlugins an object that contains the plugins which have been added to the adapter context\n * @property {context} the context for the adapter (which can be utilized in a custom template)\n * @property {function} dispose the dispose function for all internal subs\n *\n * @example\n * {\n *      \"type\": \"adapter\",\n *      \"id\": \"ADAPTER_ID\",\n *      \"dataSourceEndpoint\": [\n *          {\n *              \"uri\": \"endpoint/uri\",\n *              \"options\": {\n *                  \"type\": \"PUT\"\n *              },\n *              \"keyMap\": {\n *                  \"dataKey\": \"a\",\n *                  \"resultsKey\": \"b\"\n *              }\n *          }\n *      ],\n *      \"children\": [\n *          // children json configuration goes here\n *      ]\n * }\n */\nexport default function adapterViewModel(node) {\n    let dictionary = observable({}), // dictionary of nodes with an id\n        data = observable({}), // data of dictionary contents\n        context = {\n            metadata: node.children,\n            parentContext: this,\n            getValue: getValue,\n            dictionary: dictionary,\n            data: data,\n            id: node.id\n        },\n        mappedChildNodes = observableArray(),\n        updated = false,\n        subs = [],\n        dataSyncSubscription,\n        plugins = node.plugins ? createViewModels.call(context, node.plugins) : [],\n        contextPlugins = {};\n\n    plugins.forEach(plugin => {\n        contextPlugins[plugin.type] = plugin;\n    });\n\n    // recursive function which parses through nodes and adds nodes with an id to dictionary\n    function createDictionary(nodes) {\n        let dict = dictionary.peek();\n        nodes.forEach(node => {\n            // add node to dictionary if it isnt there yet\n            if (node.id && !dict[node.id]) {\n                dict[node.id] = node;\n                updated = true;\n            }\n            // add children to dictionary if getValue function is not exposed\n            if (!node.getValue) {\n                createDictionary(unwrap(node.mappedChildNodes) || []);\n            }\n        });\n    }\n\n    // keep the data current if the node value changed with dataSyncDescription\n    function syncDataDictionary() {\n        dataSyncSubscription = computed(() => {\n            let dict = dictionary();\n            Object.keys(dict).forEach(id => {\n                if (dict[id].getValue) {\n                    data()[id] = dict[id].getValue();\n                }\n            });\n        });\n    }\n\n    // pause dataSyncDescription and update the data\n    function updateData(newData) {\n        dataSyncSubscription && dataSyncSubscription.dispose();\n        data(newData);\n        syncDataDictionary();\n    }\n\n    // fetches the data from dataSourceEndpoint(s)\n    function fetchData() {\n        let dataSourceEndpointArray = Array.isArray(node.dataSourceEndpoint)\n            ? node.dataSourceEndpoint : [node.dataSourceEndpoint],\n            count = 0,\n            dataObject = data();\n\n        dataSourceEndpointArray.forEach(function(endpoint) {\n            if (endpoint.uri) {\n                console.warn('dataSourceEndpoint expects URI in \"target\". Please update your JSON to reflect the new syntax');\n                endpoint = merge(endpoint,{\n                    target: endpoint\n                });\n            }\n\n            createViewModel.call(context, {\n                \"type\": \"action\",\n                \"actionType\": \"ajax\",\n                \"options\": endpoint\n            }).action({\n                callback: function(error, results) {\n                    let resultsByKey,\n                        keyMap = endpoint.keyMap || {},\n                        newDataObject = {};\n\n                    count++;\n\n                    if (!error) {\n                        resultsByKey = keyMap.resultsKey ? get(results, keyMap.resultsKey) : results;\n                        // optional: keyMap.dataKey path to extend dataObject on\n                        if (keyMap.dataKey) {\n                            newDataObject[keyMap.dataKey] = resultsByKey;\n                        } else {\n                            newDataObject = resultsByKey;\n                        }\n                        extend(dataObject, newDataObject);\n                    }\n\n                    if (count === dataSourceEndpointArray.length) {\n                        updateData(dataObject);\n                        if (!mappedChildNodes().length) {\n                            mappedChildNodes(createViewModels.call(context, node.children || []));\n                        }\n                    }\n                }\n            });\n\n        });\n    }\n\n    function getValue(id) {\n        let node = dictionary()[id],\n            dataValue = (data() || {})[id];\n\n        // the node has been defined so get the value from the node\n        if (node && node.getValue) { return node.getValue(); }\n\n        // data has been defined for the node but the node doesnt exist yet\n        if (dataValue) { return dataValue; }\n\n        if (contextPlugins && contextPlugins[id]) {\n            return contextPlugins[id]();\n        }\n        return context.parentContext.getValue(id);\n    }\n\n    if (!node.lazy) {\n        mappedChildNodes(createViewModels.call(context, node.children || []));\n    }\n\n    // update dictionary if mappedChildNodes of a node updates\n    computed(() => {\n        updated = false;\n        createDictionary(mappedChildNodes())\n        if (updated) {\n            dictionary.valueHasMutated();\n        }\n    });\n\n    // initialize the data subscription\n    syncDataDictionary();\n\n    // get initial data\n    if (node.dataSourceEndpoint) {\n        fetchData();\n    }\n\n    // listen for 'refresh' event\n    subs.push(receive(node.id + '.refresh', function(options) {\n        console.log('-->', node);\n        fetchData(options);\n    }));\n\n    return merge(node, {\n        mappedChildNodes: mappedChildNodes,\n        data: data,\n        contextPlugins: contextPlugins,\n        context: context,\n        dispose: function() {\n            subs.forEach(function(sub) {\n                sub.dispose();\n            });\n        }\n    });\n};\n"]}