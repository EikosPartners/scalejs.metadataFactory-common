{"version":3,"sources":["../../src/tabs/tabsViewModel.js"],"names":["node","metadata","context","createViewModel","createViewModelUnbound","bind","options","mappedChildNodes","activeTabRegion","initialized","subs","query","tabs","initialActiveTab","setTabRoute","tabDef","currentRoute","route","path","target","params","children","forEach","tab","index","tabTemplate","headers","text","tabName","computed","getValue","tabObj","keepCache","cache","tabViewModel","setActiveTab","newRoute","validations","successCallback","setRoute","isActive","tabTypes","type","call","visible","id","console","error","push","template","initialTab","filter","some","currentIndex","newIndex","undefined","length","isChild","dispose","sub","tabViewModels","data","Array","isArray","vm","ajax","lazy","disposeNodes","nodes","createViewModels","name","tabParams","dataservice","get","uri","err","actionType","action"],"mappings":";;;;;;kBA8ImB,UAAUA,IAAV,EAAgBC,QAAhB,EAA0B;AACrC,QAAIC,UAAU,IAAd;AAAA,QACIC,kBAAkBC,yBAAuBC,IAAvB,CAA4BH,OAA5B,CADtB;AAAA,QAC4D;AACxDI,cAAUN,KAAKM,OAAL,IAAgB,EAF9B;AAAA,QAGIC,gBAHJ;AAAA,QAIIC,kBAAkB,0BAAW,EAAX,CAJtB;AAAA,QAKIC,cAAc,KALlB;AAAA,QAMIC,OAAO,EANX;AAAA,QAOIC,QAAQ,4BAAaA,KAPzB;AAAA,QAQIC,OAAO,EARX;AAAA,QASIC,gBATJ;;AAWA;AACA;AACA,aAASC,WAAT,CAAqBC,MAArB,EAA6B;AACzB,YAAIC,eAAe,4BAAaC,KAAb,IAAsB,4BAAaC,IAAb,GAAoB,MAAM,4BAAaA,IAAvC,GAA8C,EAApE,CAAnB;AAAA,YACIP,QAAQ,4BAAaA,KADzB;AAEA,gCAASI,OAAOI,MAAP,IAAiBH,YAA1B,EAAwC,qBAAML,KAAN,EAAYI,OAAOK,MAAnB,CAAxC,EAAoE,KAApE,EAA2EX,WAA3E;AACAA,sBAAc,IAAd;AACH;;AAED;AACAT,SAAKqB,QAAL,CAAcC,OAAd,CAAsB,UAAUC,GAAV,EAAeC,KAAf,EAAsB;AACxC,YAAIC,cAAc,2BAAlB;AAAA,YAAgC;AAC5BV,iBAAS,OAAOf,KAAK0B,OAAL,CAAaF,KAAb,CAAP,KAA+B,QAA/B,GAA0C,EAAEG,MAAM3B,KAAK0B,OAAL,CAAaF,KAAb,CAAR,EAA1C,GAA0ExB,KAAK0B,OAAL,CAAaF,KAAb,CADvF;AAAA,YAEII,UAAUb,OAAOc,QAAP,GAAkB,wBAAS,YAAY;AAC7C,mBAAO,0BAAWd,OAAOY,IAAlB,EAAwBzB,QAAQ4B,QAAhC,CAAP;AACH,SAF2B,CAAlB,GAELf,OAAOY,IAJhB;AAAA,YAKII,SAAS;AACLH,qBAASA,OADJ;AAELb,oBAAQA,MAFH;AAGLU,yBAAaA,WAHR;AAILO,uBAAWT,IAAIU,KAAJ,IAAajC,KAAKiC;AAJxB,SALb;AAAA,YAWIC,YAXJ;;AAaD;AACA;AACAH,eAAOI,YAAP,GAAsB,UAAUC,QAAV,EAAoB;AACtC,gBAAI9B,QAAQ+B,WAAR,IAAuB/B,QAAQ+B,WAAR,CAAoBtB,OAAOY,IAA3B,CAA3B,EAA6D;AACzD,sCAAOrB,QAAQ+B,WAAR,CAAoBtB,OAAOY,IAA3B,CAAP,EAAyC;AACrCW,qCAAiB,2BAAW;AACxB9B,wCAAgBiB,aAAhB;AACA,4BAAInB,QAAQiC,QAAR,KAAqB,KAAzB,EAAgC;AAC5BzB,wCAAYsB,YAAYrB,MAAxB;AACH;AACJ;AANoC,iBAAzC;AAQH,aATD,MASO;AACFP,gCAAgBiB,aAAhB;AACA,oBAAInB,QAAQiC,QAAR,KAAqB,KAAzB,EAAgC;AAC5BzB,gCAAYsB,YAAYrB,MAAxB;AACH;AACL;AACJ,SAhBD;;AAkBA;AACAgB,eAAOS,QAAP,GAAkB,wBAAS,YAAY;AAClC,mBAAOhC,sBAAsBiB,aAA7B;AACH,SAFgB,CAAlB;;AAIC;AACA;AACA,YAAIgB,SAASlB,IAAImB,IAAb,CAAJ,EAAwB;AACpBR,2BAAeO,SAASlB,IAAImB,IAAb,EAAmBC,IAAnB,CAAwBzC,OAAxB,EAAiC6B,MAAjC,EAAyCR,GAAzC,CAAf;AACH,SAFD,MAEO;AACHW,2BAAe/B,gBAAgBoB,GAAhB,CAAf;AACAE,wBAAY,wBAAS,wBAAT,EAAmCS,YAAnC,CAAZ;AACH;;AAED,4BAAOH,MAAP,EAAeG,YAAf;;AAEA;AACA,YAAG,mBAAInB,OAAO6B,OAAX,CAAH,EAAwB;AACpBb,mBAAOa,OAAP,GAAiB,kBAAG7B,OAAO6B,OAAV,EAAmB,SAAnB,IACb7B,OAAO6B,OADM,GAEX,wBAAS,YAAW;AAClB,uBAAO,wBAAS7B,OAAO6B,OAAhB,EAAyB1C,QAAQ4B,QAAR,IAAoB,UAAUe,EAAV,EAAc;AAC9DC,4BAAQC,KAAR,CAAc,0EAAd,EAA0FhB,MAA1F;AACH,iBAFM,CAAP;AAGH,aAJC,CAFN;AAOH,SARD,MAQO;AACHA,mBAAOa,OAAP,GAAiB,IAAjB;AACH;;AAEDhC,aAAKoC,IAAL,CAAUjB,MAAV;;AAEA;AACA,YAAGhB,OAAOyB,QAAP,IAAmBzB,OAAOK,MAAP,IAAiBT,KAAjB,IAA0B,8BAAeA,KAAf,EAAsBI,OAAOK,MAA7B,CAAhD,EAAsF;AAClFP,+BAAmBkB,MAAnB;AACH;AACJ,KArED;;AAuEA,QAAIlB,gBAAJ,EAAsB;AAClBA,yBAAiBsB,YAAjB;AACH,KAFD,MAEO,IAAI,CAAC3B,kBAAkByC,QAAvB,EAAiC;AACpC;;AAEA;AACA,YAAIC,aAAatC,KAAKuC,MAAL,CAAY,UAAC5B,GAAD,EAAS;AAClC,mBAAO,sBAAOA,IAAIqB,OAAX,CAAP;AACH,SAFgB,EAEd,CAFc,CAAjB;;AAIAM,sBAAcA,WAAWf,YAAX,EAAd;AACH;;AAED;AACA,QAAGnC,KAAK6C,EAAR,EAAY;AACRnC,aAAKsC,IAAL,CAAU,uBAAQhD,KAAK6C,EAAL,GAAS,eAAjB,EAAkC,UAAUzB,MAAV,EAAkB;AAC1DR,iBAAKwC,IAAL,CAAU,UAAS7B,GAAT,EAAc;AACpB;AACA;AACA,oBAAG,8BAAeH,MAAf,EAAuBG,IAAIR,MAAJ,CAAWK,MAAlC,CAAH,EAA8C;AAC1CG,wBAAIY,YAAJ,CAAiB,qBAAM,uBAAUZ,IAAIR,MAAd,CAAN,EAA6B,EAAEK,QAAQA,MAAV,EAA7B,CAAjB;AACH;AACJ,aAND;AAOH,SARS,CAAV;;AAUAV,aAAKsC,IAAL,CAAU,uBAAQhD,KAAK6C,EAAL,GAAQ,aAAhB,EAA+B,YAAY;AACjD,gBAAIQ,eAAgB,CAApB;AAAA,gBACIC,QADJ;;AAGA1C,iBAAKwC,IAAL,CAAU,UAAS7B,GAAT,EAAcC,KAAd,EAAqB;AAC3B,oBAAIhB,qBAAqBe,IAAIE,WAAJ,EAAzB,EAA4C;AACxC4B,mCAAe7B,KAAf;AACH;AACJ,aAJD;;AAMA,mBAAM8B,aAAaC,SAAnB,EAA8B;AAC1B,oBAAI,CAAC3C,KAAK,CAACyC,eAAa,CAAd,IAAmBzC,KAAK4C,MAA7B,EAAqCC,OAA1C,EAAmD;AAC/CH,+BAAWD,eAAc,CAAzB;AACH,iBAFD,MAEO;AACHA;AACH;AACJ;;AAEDzC,iBAAK0C,QAAL,EAAenB,YAAf;AACH,SAnBS,CAAV;AAoBH;;AAED,WAAO,qBAAMnC,IAAN,EAAY;AACfY,cAAMA,IADS;AAEfL,0BAAkBK,IAFH;AAGfJ,yBAAiBA,eAHF;AAIfN,iBAAS,IAJM;AAKfwD,iBAAS,mBAAY;AACjBhD,iBAAKY,OAAL,CAAa,UAAUqC,GAAV,EAAe;AACxBA,oBAAID,OAAJ;AACH,aAFD;;AAIA9C,iBAAKU,OAAL,CAAa,UAAUC,GAAV,EAAe;AACxB,oBAAIqC,gBAAgBrC,IAAIE,WAAJ,MAAqBF,IAAIE,WAAJ,GAAkBwB,QAAlB,CAA2BY,IAApE;AACA;AACA,oBAAID,iBAAiB,CAACE,MAAMC,OAAN,CAAcH,aAAd,CAAtB,EAAoD;AAChDA,oCAAgB,CAACA,aAAD,CAAhB;AACH;AACD,iBAACA,iBAAiB,EAAlB,EAAsBtC,OAAtB,CAA8B,UAAS0C,EAAT,EAAa;AACvCA,0BAAMA,GAAGN,OAAT,IAAoBM,GAAGN,OAAH,EAApB;AACH,iBAFD;AAGH,aATD;AAUH;AApBc,KAAZ,CAAP;AAsBH,C;;AAhTL;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;AAEI;AACA;AACA;AACA;AACA;AACA,IAAIjB,WAAW;AACXwB,UAAMA,IADK;AAEXhD,WAAOA,KAFI;AAGXiD,UAAMA;AAHK,CAAf;;AAMA,SAASC,YAAT,CAAsBC,KAAtB,EAA6B;AACzB,0BAAOA,KAAP,EAAc9C,OAAd,CAAsB,gBAAQ;AAC1BtB,aAAK0D,OAAL,IAAgB1D,KAAK0D,OAAL,EAAhB;AACAS,qBAAanE,KAAKO,gBAAL,IAAyB,EAAtC;AACH,KAHD;AAIH;;AAED,SAAS2D,IAAT,CAAcnC,MAAd,EAAsBR,GAAtB,EAA2B;AACvB,QAAIhB,mBAAmB,gCAAvB;AAAA,QACI4B,eAAeJ,OAAOI,YAD1B;AAAA,QAEIV,cAAcM,OAAON,WAFzB;AAAA,QAGIvB,UAAU,IAHd;;AAKA6B,WAAOxB,gBAAP,GAA0BA,gBAA1B;;AAEAwB,WAAOI,YAAP,GAAsB,UAAUC,QAAV,EAAoB;AACtC,YAAI,CAAC7B,mBAAmBiD,MAApB,IAA8B,CAACzB,OAAOC,SAA1C,EAAqD;AACjD,gBAAIzB,mBAAmBiD,MAAvB,EAA+B;AAC3BW,6BAAa5D,kBAAb;AACH;AACDA,6BAAiB8D,0BAAiB1B,IAAjB,CAAsBzC,OAAtB,EAA+BqB,IAAIF,QAAnC,CAAjB;AACAI,wBAAY;AACRwB,0BAAU;AACNqB,0BAAM,yBADA;AAENT,0BAAMtD;AAFA,iBADF;AAKRwB,wBAAQA;AALA,aAAZ;AAOAI,yBAAaC,QAAb;AACH,SAbD,MAaO;AACHD,yBAAaC,QAAb;AACH;AACJ,KAjBD;;AAmBA,WAAOL,MAAP;AACH;;AAED,SAASkC,IAAT,CAAclC,MAAd,EAAsBR,GAAtB,EAA2B;AACvB,QAAIgD,YAAYhD,IAAIjB,OAAJ,IAAeiB,IAAIjB,OAAJ,CAAYc,MAA3C;AAAA,QACIe,eAAeJ,OAAOI,YAD1B;AAAA,QAEIV,cAAcM,OAAON,WAFzB;AAAA,QAGIlB,mBAAmB,gCAHvB;AAAA,QAIIL,UAAU,IAJd;;AAMA;AACA6B,WAAOxB,gBAAP,GAA0BA,gBAA1B;;AAEA;AACAwB,WAAOI,YAAP,GAAsB,UAASC,QAAT,EAAmB;AACrC,YAAI,CAACX,aAAD,IAAkB,CAACM,OAAOC,SAA9B,EAAyC;AACrC,gBAAGP,aAAH,EAAkB;AACdA,8BAAcwB,QAAd,CAAuBY,IAAvB,CAA4BvC,OAA5B,CAAoC,UAAUtB,IAAV,EAAgB;AAChD;AACA,wBAAIA,KAAK0D,OAAT,EAAkB;AACd1D,6BAAK0D,OAAL;AACH;AACJ,iBALD;AAMH;AACDc,kCAAYC,GAAZ,CAAgB,EAACC,KAAInD,IAAI0C,IAAT,EAAhB,EAAgC,UAAUU,GAAV,EAAe1E,QAAf,EAAyB;AACrD,oBAAI0E,GAAJ,EAAS;AACL7B,4BAAQC,KAAR,CAAc,mBAAd,EAAkC4B,GAAlC;AACH;;AAED,oBAAI;AACApE,qCAAiB8D,0BAAiB1B,IAAjB,CAAsBzC,OAAtB,EAA+B4D,MAAMC,OAAN,CAAc9D,QAAd,IAA0BA,QAA1B,GAAqC,CAACA,QAAD,CAApE,CAAjB;AACH,iBAFD,CAEE,OAAO0E,GAAP,EAAY;AACV7B,4BAAQC,KAAR,CAAc4B,GAAd;AACH;;AAGD;AACAlD,4BAAY;AACRwB,8BAAU;AACNqB,8BAAM,yBADA;AAENT,8BAAMtD;AAFA,qBADF;AAKRwB,4BAAQA;AALA,iBAAZ;AAOAI,6BAAaC,QAAb;AACH,aArBD;AAsBH,SA/BD,MA+BO;AACHD,yBAAaC,QAAb;AACH;AACJ,KAnCD;AAoCA;AACA,QAAImC,SAAJ,EAAe;AACXhD,YAAI0C,IAAJ,GAAW,4BAAatD,KAAb,IAAsB,4BAAaA,KAAb,CAAmB4D,SAAnB,CAAtB,GAAsDhD,IAAI0C,IAAJ,GAAW,4BAAatD,KAAb,CAAmB4D,SAAnB,CAAjE,GAAiGhD,IAAI0C,IAAhH;AACH;;AAED,WAAOlC,MAAP;AACH;;AAED;AACA;AACA,SAASd,KAAT,CAAec,MAAf,EAAuBR,GAAvB,EAA4B;AACxB,QAAIrB,UAAU,IAAd,CADwB,CACJ;;AAEpB;AACA6B,WAAOI,YAAP,GAAsB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACAhC,iCAAgBwC,IAAhB,CAAqBzC,OAArB,EAA8B;AAC1BwC,kBAAM,QADoB;AAE1BkC,wBAAY,OAFc;AAG1BtE,qBAAS;AACLa,wBAAQI,IAAIN,KAAJ,CAAUE,MADb;AAELC,wBAAQ,qBACJ,4BAAaT,KADT,EAEJoB,OAAOhB,MAAP,CAAcK,MAFV,EAGJG,IAAIN,KAAJ,CAAUG,MAHN;AAFH;AAHiB,SAA9B,EAWGyD,MAXH;AAYH,KAlBD;AAmBA,WAAO9C,MAAP;AACH;;AAoKA","file":"tabsViewModel.js","sourcesContent":["import { createViewModel, createViewModels, createViewModel as createViewModelUnbound } from 'scalejs.metadataFactory';\nimport { registerTemplates, registerBindings, template } from 'scalejs.mvvm';\nimport { observable, observableArray, computed, unwrap } from 'knockout';\nimport { getCurrent, setRoute } from 'scalejs.navigation';\nimport { receive, notify } from 'scalejs.messagebus';\nimport { evaluate } from 'scalejs.expression-jsep';\nimport { objectContains, formatText } from './tabUtils';\nimport { extend, cloneDeep } from 'lodash';\nimport { is, has, merge } from 'scalejs';\nimport dataservice from 'dataservice';\n\n    // tabsViewModel\n    // tabs displays clickable links that can be used to modify the contents of an active section\n    // there is one special tabType right now called ajax which will make a new ajax request when the tab is clicked\n    // otherwise the tab will be the mappedChildNodes\n    // todo: refactor tabObj/tabDef to be more clear?\n    var tabTypes = {\n        ajax: ajax,\n        route: route,\n        lazy: lazy\n    };\n\n    function disposeNodes(nodes) {\n        unwrap(nodes).forEach(node => {\n            node.dispose && node.dispose();\n            disposeNodes(node.mappedChildNodes || []);\n        });\n    }\n\n    function lazy(tabObj, tab) {\n        var mappedChildNodes = observableArray(),\n            setActiveTab = tabObj.setActiveTab,\n            tabTemplate = tabObj.tabTemplate,\n            context = this;\n\n        tabObj.mappedChildNodes = mappedChildNodes;\n\n        tabObj.setActiveTab = function (newRoute) {\n            if (!mappedChildNodes().length || !tabObj.keepCache) {\n                if (mappedChildNodes().length) {\n                    disposeNodes(mappedChildNodes());\n                }\n                mappedChildNodes(createViewModels.call(context, tab.children));\n                tabTemplate({\n                    template: {\n                        name: 'metadata_items_template',\n                        data: mappedChildNodes()\n                    },\n                    tabObj: tabObj\n                });\n                setActiveTab(newRoute);\n            } else {\n                setActiveTab(newRoute);\n            }\n        };\n\n        return tabObj;\n    }\n\n    function ajax(tabObj, tab) {\n        var tabParams = tab.options && tab.options.params,\n            setActiveTab = tabObj.setActiveTab,\n            tabTemplate = tabObj.tabTemplate,\n            mappedChildNodes = observableArray(),\n            context = this;\n\n        // update everything when mapped child nodes changes\n        tabObj.mappedChildNodes = mappedChildNodes;\n\n        // override tab setActiveTab so that new ajax request is made for first load\n        tabObj.setActiveTab = function(newRoute) {\n            if (!tabTemplate() || !tabObj.keepCache) {\n                if(tabTemplate()) {\n                    tabTemplate().template.data.forEach(function (node) {\n                        // todo - call dispose on mapped child nodes of each node\n                        if (node.dispose) {\n                            node.dispose();\n                        }\n                    });\n                }\n                dataservice.get({uri:tab.ajax}, function (err, metadata) {\n                    if (err) {\n                        console.error('there is an error',err);\n                    }\n\n                    try {\n                        mappedChildNodes(createViewModels.call(context, Array.isArray(metadata) ? metadata : [metadata]));\n                    } catch (err) {\n                        console.error(err);\n                    }\n\n\n                    // need to pass tabObj to the activeTabRegion to be able to code dynamic logic in custom binding\n                    tabTemplate({\n                        template: {\n                            name: 'metadata_items_template',\n                            data: mappedChildNodes()\n                        },\n                        tabObj: tabObj\n                    });\n                    setActiveTab(newRoute);\n                });\n            } else {\n                setActiveTab(newRoute);\n            }\n        }\n        // todo refactor to pass params\n        if (tabParams) {\n            tab.ajax = getCurrent().query && getCurrent().query[tabParams] ? tab.ajax + getCurrent().query[tabParams] : tab.ajax;\n        }\n\n        return tabObj;\n    }\n\n    // tabObj - the ViewModel for the tab itself (not the contents)\n    // tab - the definition of the Tab contents\n    function route(tabObj, tab) {\n        var context = this; // want to pass context incase it has data\n\n        // override tab setActiveTab so that a route is performed\n        tabObj.setActiveTab = function () {\n            // merge the params from route with current query as not to overwrite it\n            // also merge with the tabObj.tabDef.params so that the tab initializes correctly\n            // for the objectContains check below, if the tabDef.params is part of the query it will use that tab as the initial tab\n            // so we need to make sure, that if we're setting a tabRoute, that the params of the last tab are overwriten with the params in the current tab\n            // so you dont get another route accidentally\n            createViewModel.call(context, {\n                type: 'action',\n                actionType: 'route',\n                options: {\n                    target: tab.route.target,\n                    params: merge(\n                        getCurrent().query,\n                        tabObj.tabDef.params,\n                        tab.route.params\n                    )\n                }\n            }).action();\n        }\n        return tabObj;\n    }\n\n    export default function (node, metadata) {\n        var context = this,\n            createViewModel = createViewModelUnbound.bind(context), //ensures context is passed\n            options = node.options || {},\n            mappedChildNodes,\n            activeTabRegion = observable({}),\n            initialized = false,\n            subs = [],\n            query = getCurrent().query,\n            tabs = [],\n            initialActiveTab;\n\n        // when tabs are selected update the tab route\n        // do not update tabroute on initialization, just replace\n        function setTabRoute(tabDef) {\n            var currentRoute = getCurrent().route + (getCurrent().path ? '/' + getCurrent().path : '' ),\n                query = getCurrent().query;\n            setRoute(tabDef.target || currentRoute, merge(query,tabDef.params), false, initialized);\n            initialized = true;\n        }\n\n        // zip the children tabs with the tab defs\n        node.children.forEach(function (tab, index) {\n            var tabTemplate = observable(), // can by dynamic because of ajax tabs\n                tabDef = typeof node.headers[index] === 'string' ? { text: node.headers[index] } : node.headers[index],\n                tabName = tabDef.computed ? computed(function () {\n                    return formatText(tabDef.text, context.getValue);\n                }) : tabDef.text,\n                tabObj = {\n                    tabName: tabName,\n                    tabDef: tabDef,\n                    tabTemplate: tabTemplate,\n                    keepCache: tab.cache || node.cache\n                },\n                tabViewModel;\n\n           // sets the active tab region to the tab template\n           // sets newRoute if defined, else sets tabRoute\n           tabObj.setActiveTab = function (newRoute) {\n               if (options.validations && options.validations[tabDef.text]) {\n                   notify(options.validations[tabDef.text], {\n                       successCallback: function() {\n                           activeTabRegion(tabTemplate());\n                           if (options.setRoute !== false) {\n                               setTabRoute(newRoute || tabDef);\n                           }\n                       }\n                   });\n               } else {\n                    activeTabRegion(tabTemplate());\n                    if (options.setRoute !== false) {\n                        setTabRoute(newRoute || tabDef);\n                    }\n               }\n           };\n\n           // tab is active when the active region is the template\n           tabObj.isActive = computed(function () {\n                return activeTabRegion() === tabTemplate();\n            });\n\n            // create tabViewModel from type if defined\n            // else call createViewModel\n            if (tabTypes[tab.type]) {\n                tabViewModel = tabTypes[tab.type].call(context, tabObj, tab)\n            } else {\n                tabViewModel = createViewModel(tab)\n                tabTemplate(template('metadata_item_template', tabViewModel));\n            }\n\n            extend(tabObj, tabViewModel);\n\n            // visible expression binding using context' getValue\n            if(has(tabDef.visible)) {\n                tabObj.visible = is(tabDef.visible, 'boolean') ?\n                    tabDef.visible\n                    : computed(function() {\n                        return evaluate(tabDef.visible, context.getValue || function (id) {\n                            console.error('Trying to evaluate a binding when getValue isnt specified on the context', tabObj);\n                        });\n                    });\n            } else {\n                tabObj.visible = true;\n            }\n\n            tabs.push(tabObj);\n\n            // sets the active tab if defined in the query or tabDef\n            if(tabDef.isActive || tabDef.params && query && objectContains(query, tabDef.params)) {\n                initialActiveTab = tabObj;\n            }\n        });\n\n        if (initialActiveTab) {\n            initialActiveTab.setActiveTab();\n        } else if (!activeTabRegion().template) {\n            // initialize to first tab if we havent routed to a specific tab\n\n            // will set first visible tab to active tab\n            let initialTab = tabs.filter((tab) => {\n                return unwrap(tab.visible);\n            })[0];\n\n            initialTab && initialTab.setActiveTab();\n        }\n\n        // receive events to set active tab\n        if(node.id) {\n            subs.push(receive(node.id +'.setActiveTab', function (params) {\n                tabs.some(function(tab) {\n                    // if activeTab: 'x' is in both objects, set the active tab\n                    // and write this better..maybe use ids\n                    if(objectContains(params, tab.tabDef.params)) {\n                        tab.setActiveTab(merge(cloneDeep(tab.tabDef), { params: params }));\n                    }\n                });\n            }));\n\n            subs.push(receive(node.id+'.setNextTab', function () {\n                var currentIndex =  0,\n                    newIndex;\n\n                tabs.some(function(tab, index) {\n                    if (activeTabRegion() == tab.tabTemplate()) {\n                        currentIndex = index;\n                    }\n                })\n\n                while(newIndex === undefined) {\n                    if (!tabs[(currentIndex+1) % tabs.length].isChild) {\n                        newIndex = currentIndex +1;\n                    } else {\n                        currentIndex++\n                    }\n                }\n\n                tabs[newIndex].setActiveTab();\n            }));\n        }\n\n        return merge(node, {\n            tabs: tabs,\n            mappedChildNodes: tabs,\n            activeTabRegion: activeTabRegion,\n            context: this,\n            dispose: function () {\n                subs.forEach(function (sub) {\n                    sub.dispose();\n                });\n\n                tabs.forEach(function (tab) {\n                    var tabViewModels = tab.tabTemplate() && tab.tabTemplate().template.data;\n                    // why is tab viewmodels an array, anyway?\n                    if (tabViewModels && !Array.isArray(tabViewModels)) {\n                        tabViewModels = [tabViewModels];\n                    }\n                    (tabViewModels || []).forEach(function(vm) {\n                        vm && vm.dispose && vm.dispose();\n                    });\n                });\n            }\n        });\n    };\n"]}