{"version":3,"sources":["../../src/list/listViewModel.js"],"names":["listViewModel","listItems","DELETE","del","DELETE_FLAG","deleteFlag","itemDef","context","clonedItem","cloneDeep","template","id","undefined","name","data","isNew","call","getValue","deleteRow","options","clearOnDelete","item","itemDictionary","setValue","node","rows","isShown","readonly","deleteRows","mappedChildNodes","unique","visibleRows","initialData","addButtonRendered","bind","minRequiredRows","showRemoveButton","scrolled","onlyIf","setReadonly","bool","forEach","row","rowViewModel","initialValues","items","rowContext","metadata","editMode","dict","Object","keys","reduce","d","prop","itemViewModels","rowReadonly","error","inputValue","index","indexOf","map","_item","input","console","type","ret","visible","add","rowVm","remove","dispose","push","unshift","setTimeout","some","rendered","hasFocus","listData","originalRowItems","peek","dataObj","itemKey","filter","dontSendIfEmpty","obj","sendNullIfEmpty","length","initialize","Array","isArray","removeAll","trackDiffChanges","set","i","newData","reverse","lastRow","validations","required","minRows","params","isRequired","r","subscribeToData","warn","subscribe","infinite","newRows","slice","event","elem","target","currentRows","scrollTop","scrollHeight","offsetHeight","seed","allRows","showRemove"],"mappings":";;;;;kBA4EwBA,a;;AA5ExB;;AACA;;AACA;;AACA;;;;AACA;;AACA;;;;;;AAEI;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAcJ,IAAMC,YAAY;AACdC,YAAQC,GADM;AAEdC,iBAAaC;AAFC,CAAlB;;AAKA,SAASF,GAAT,CAAaG,OAAb,EAAsB;AAClB,QAAMC,UAAU,IAAhB;AAAA,QACIC,aAAa,iBAAEC,SAAF,CAAYH,OAAZ,CADjB;;AAGA,WAAOE,WAAWE,QAAlB,CAJkB,CAIU;;AAE5B,WAAO,qBAAMF,UAAN,EAAkB;AACrBG,YAAIC,SADiB;AAErBF,kBAAU;AACNG,kBAAMP,QAAQI,QAAR,IAAoB,mBADpB;AAENI,kBAAMP;AAFA;AAFW,KAAlB,CAAP;AAOH;;AAED,SAASF,UAAT,CAAoBC,OAApB,EAA6B;AACzB,QAAMC,UAAU,IAAhB;AACI;AACA;AACJ,WAAOA,QAAQQ,KAAR,GAAgBZ,IAAIa,IAAJ,CAAST,OAAT,EAAkBD,OAAlB,CAAhB,GAA6C,qBAAMC,OAAN,EAAe;AAC/DG,kBAAU,wBADqD;AAE/DO,kBAAU,oBAAY;AAClB,mBAAOV,QAAQF,UAAR,KAAuB,GAAvB,GAA6B,GAApC;AACH,SAJ8D;AAK/Da,mBAAW,qBAAY;AACnBX,oBAAQF,UAAR,CAAmB,IAAnB;AACA,gBAAIC,QAAQa,OAAR,IAAmBb,QAAQa,OAAR,CAAgBC,aAAvC,EAAsD;AAClD,oBAAMC,OAAOd,QAAQe,cAAR,GAAyBhB,QAAQa,OAAR,CAAgBC,aAAzC,CAAb;AACA,oBAAIC,QAAQA,KAAKE,QAAjB,EAA2B;AACvBF,yBAAKE,QAAL,CAAc,CAAd;AACH;AACJ;AACJ;AAb8D,KAAf,EAcjDjB,OAdiD,CAApD;AAeH;;AAGc,SAASN,aAAT,CAAuBwB,IAAvB,EAA6B;AACxC,QAAMC,OAAO,gCAAb;AAAA,QACIN,UAAUK,KAAKL,OAAL,IAAgB,EAD9B;AAAA,QAEIO,UAAU,0BAAW,IAAX,CAFd;AAAA,QAGInB,UAAU,QAAQ,EAHtB;;AAII;AACAoB,eAAW,0BAAYpB,QAAQoB,QAAR,IAAoBpB,QAAQoB,QAAR,EAArB,IAA4C,KAAvD,CALf;AAAA,QAMIC,aAAa,0BAAWT,QAAQS,UAAR,KAAuB,KAAlC,CANjB;;AAOQ;AACJC,uBAAmB,gCARvB;AAAA,QASIf,OAAO,0BAAWU,KAAKV,IAAhB,CATX;AAAA,QAUIgB,SAAS,EAVb;AAAA,QAWIC,cAAc,gCAXlB;AAAA,QAYIC,cAAc,iBAAEvB,SAAF,CAAYe,KAAKV,IAAjB,KAA0B,EAZ5C;AAAA,QAaImB,oBAAoB,kBAAGT,KAAKS,iBAAR,EAA2B,QAA3B,IACZ,wBAAS,mBAASC,IAAT,CAAc,IAAd,EAAoBV,KAAKS,iBAAzB,EAA4C1B,QAAQU,QAApD,CAAT,CADY,GAEV,0BAAWO,KAAKS,iBAAL,KAA2B,KAAtC,CAfd;AAgBA,QAAIE,kBAAkB,CAAtB;AAAA,QACIC,mBAAmB,IADvB;AAAA,QAEIC,iBAFJ;AAAA,QAGIC,eAHJ;;AAKA,aAASC,WAAT,CAAqBC,IAArB,EAA2B;AACvBb,iBAASa,IAAT,EADuB,CACP;AAChBf,eAAOgB,OAAP,CAAe,UAACC,GAAD,EAAS;AAAE;AACtBA,gBAAIf,QAAJ,CAAaa,IAAb;AACH,SAFD;AAGH;;AAEG;AACA;AACA;AACJ,aAASG,YAAT,CAAsBC,aAAtB,EAAqC7B,KAArC,EAA4C;AACxC,YAAM8B,QAAQ,gCAAd;AAAA,YAAiC;AAC7B;AACAvB,yBAAiB,0BAAW,EAAX,CAFrB;AAAA,YAGIwB,aAAa;AACTC,sBAAUxC,QAAQwC,QADT,EACmB;AAC5BtB,kBAAMA,IAFG;AAGTK,oBAAQA,MAHC;AAITf,mBAAOA,KAJE;AAKTO,4BAAgBA,cALP;AAMT0B,sBAAU,0BAAW,KAAX,CAND,EAMoB;AAC7B3C,wBAAY,0BAAW,KAAX,CAPH;AAQTS,kBAAM,wBAAS,YAAM;AACjB,oBAAMmC,OAAO3B,gBAAb;AACA,uBAAO4B,OAAOC,IAAP,CAAYF,IAAZ,EAAkBG,MAAlB,CAAyB,UAACC,CAAD,EAAI1C,EAAJ,EAAW;AACvC,wBAAMU,OAAO4B,KAAKtC,EAAL,CAAb;AACA,wBAAIU,QAAQA,KAAKJ,QAAjB,EAA2B;AACvBoC,0BAAE1C,EAAF,IAAQU,KAAKJ,QAAL,EAAR;AACH,qBAFD,MAEO;AACHoC,0BAAE1C,EAAF,IAAQU,IAAR;AACH;AACD,2BAAOgC,CAAP;AACH,iBARM,EAQJ,EARI,CAAP;AASH,aAXK;AARG,SAHjB;AAAA,YAwBIX,MAAM,EAxBV,CADwC,CAyB1B;AACd,YAAIY,aAAJ;AAAA,YACIC,iBAAiB,IADrB;AAAA,YAEIC,oBAFJ;;AAII;AACJV,mBAAWnB,QAAX,GAAsB,0BAAWA,UAAX,CAAtB;;AAEI;AACJ,YAAI,kBAAGR,QAAQqC,WAAX,EAAwB,QAAxB,CAAJ,EAAuC;AACnCA,0BAAc,wBAAS,YAAM;AACzB,oBAAIV,WAAWnB,QAAX,IAAuBmB,WAAWnB,QAAX,EAA3B,EAAkD;AAC9C,2BAAO,IAAP,CAD8C,CACjC;AAChB;AACG;AACJ,uBAAO,wBAASR,QAAQqC,WAAjB,EAA8B,UAAC7C,EAAD,EAAQ;AACzC,wBAAMU,OAAOC,iBAAiBX,EAAjB,CAAb;AACA,wBAAIU,QAAQA,KAAKJ,QAAjB,EAA2B;AACvB,+BAAOI,KAAKJ,QAAL,EAAP;AACH;AACJ,iBALM,CAAP;AAMH,aAXa,CAAd;AAYH;;AAEG;AACJ,iBAASwC,KAAT,CAAe9C,EAAf,EAAmB;AACf,gBAAMU,OAAOC,iBAAiBX,EAAjB,CAAb;AACA,gBAAIU,QAAQA,KAAKqC,UAAb,IAA2BrC,KAAKqC,UAAL,CAAgBD,KAA/C,EAAsD;AAClD,uBAAOpC,KAAKqC,UAAL,CAAgBD,KAAhB,EAAP;AACH;AACJ;;AAEG;AACJX,mBAAWa,KAAX,GAAmB,wBAAS;AAAA,mBAAMlC,OAAOmC,OAAP,CAAelB,GAAf,CAAN;AAAA,SAAT,CAAnB;;AAEI;AACA;AACJI,mBAAW7B,QAAX,GAAsB,UAAUN,EAAV,EAAc;AAChC,gBAAIA,OAAO,OAAX,EAAoB;AAChB,uBAAOmC,WAAWa,KAAX,EAAP;AACH;AACD,gBAAIhD,OAAO,MAAX,EAAmB;AACf,uBAAOc,MAAP;AACH;AACD,gBAAId,OAAO,KAAX,EAAkB;AACd,uBAAOc,OAAOqB,WAAWa,KAAX,EAAP,CAAP;AACH;AACD,gBAAIhD,OAAO,OAAX,EAAoB;AAChB,uBAAO8C,KAAP;AACH;AACG;AACJ,gBAAMpC,OAAOC,iBAAiBX,EAAjB,CAAb;AACA,gBAAIU,QAAQA,KAAKJ,QAAjB,EAA2B;AACvB,uBAAOI,KAAKJ,QAAL,EAAP;AACH;;AAEG;AACJ,gBAAI,mBAAII,IAAJ,CAAJ,EAAe;AACX,uBAAO,sBAAOA,IAAP,CAAP;AACH;;AAEDiC,mBAAOR,WAAWnC,EAAX,CAAP;;AAEA,gBAAI,mBAAI2C,IAAJ,CAAJ,EAAe;AACX,uBAAO,sBAAOA,IAAP,CAAP;AACH;;AAED,mBAAO/C,QAAQU,QAAR,CAAiBN,EAAjB,CAAP;AACH,SA/BD;;AAkCA4C,yBAAiB/B,KAAKqB,KAAL,CAAWgB,GAAX,CAAe,UAACC,KAAD,EAAW;AACvC;AACA,gBAAMzC,OAAO,iBAAEZ,SAAF,CAAYqD,KAAZ,CAAb;;AAEI;AACA;AACA;AACJ,gBAAIN,eAAenC,KAAK0C,KAApB,IAA6B,CAAC,mBAAI1C,KAAK0C,KAAL,CAAWpC,QAAf,CAAlC,EAA4D;AACxDN,qBAAK0C,KAAL,CAAWpC,QAAX,GAAsB6B,WAAtB;AACH;;AAED,gBAAInC,KAAKF,OAAL,IAAgBE,KAAKF,OAAL,CAAaW,MAAjC,EAAyC;AACrC,oBAAI,CAACT,KAAKV,EAAV,EAAc;AACVqD,4BAAQP,KAAR,CAAc,sCAAd;AACH,iBAFD,MAEO,IAAI,CAAC3B,OAAOT,KAAKV,EAAZ,CAAL,EAAsB;AAAE;AAC3BmB,2BAAOT,KAAKV,EAAZ,IAAkB,gCAAlB;AACH;AACJ;;AAEG;AACJ,gBAAIV,UAAUoB,KAAK4C,IAAf,CAAJ,EAA0B;AACtB,oBAAMC,MAAMjE,UAAUoB,KAAK4C,IAAf,EAAqBjD,IAArB,CAA0B8B,UAA1B,EAAsCzB,IAAtC,CAAZ;AACA,oBAAIA,KAAK8C,OAAT,EAAkB;AACdD,wBAAIC,OAAJ,GAAc,wBAAS;AAAA,+BAAM,wBAAS9C,KAAK8C,OAAd,EAAuBrB,WAAW7B,QAAlC,CAAN;AAAA,qBAAT,CAAd;AACH;AACD,uBAAOiD,GAAP;AACH;AACD,mBAAO,yBAAgBlD,IAAhB,CAAqB8B,UAArB,EAAiCzB,IAAjC,CAAP;AACH,SA5BgB,CAAjB;;AA8BI;AACJ,YAAIuB,aAAJ,EAAmB;AACfW,2BAAed,OAAf,CAAuB,UAACpB,IAAD,EAAU;AAC7B;AACA;AACA,oBAAIuB,cAAcvB,KAAKV,EAAnB,CAAJ,EAA4B;AACxBU,yBAAKE,QAAL,IAAiBF,KAAKE,QAAL,CAAcqB,cAAcvB,KAAKV,EAAnB,CAAd,CAAjB;AACH;AACJ,aAND;AAOH;;AAEG;AACJkC,cAAMU,cAAN;;AAEI;AACA;AACA;AACJjC,uBAAeiC,eAAeH,MAAf,CAAsB,UAACH,IAAD,EAAO5B,IAAP,EAAgB;AACjD,gBAAI,mBAAIA,KAAKV,EAAT,CAAJ,EAAkB;AACdsC,qBAAK5B,KAAKV,EAAV,IAAgBU,IAAhB;AACAqB,oBAAIrB,KAAKV,EAAT,IAAeU,KAAKqC,UAApB;AACH;AACD,mBAAOT,IAAP;AACH,SANc,EAMZ,qBAAML,iBAAiB,EAAvB,CANY,CAAf;AAOA;;AAEA;AACA;AACAF,YAAIG,KAAJ,GAAYA,KAAZ;AACAH,YAAIpB,cAAJ,GAAqBA,cAArB;AACAoB,YAAIb,gBAAJ,GAAuBgB,KAAvB;AACAH,YAAIM,QAAJ,GAAeF,WAAWE,QAA1B;AACAN,YAAIrC,UAAJ,GAAiByC,WAAWzC,UAA5B;AACAqC,YAAIf,QAAJ,GAAe,UAAUa,IAAV,EAAgB;AAC3BK,oBAAQJ,OAAR,CAAgB,UAACpB,IAAD,EAAU;AACtB,oBAAIA,KAAKkB,WAAT,EAAsB;AAClBlB,yBAAKkB,WAAL,CAAiBC,IAAjB;AACH,iBAFD,MAEO,IAAInB,KAAKM,QAAT,EAAmB;AACtBN,yBAAKM,QAAL,CAAca,IAAd;AACH;AACJ,aAND;AAOH,SARD;;AAUA,eAAOE,GAAP;AACH;;AAEG;AACJ,aAAS0B,GAAT,CAAa1B,GAAb,EAAkB3B,KAAlB,EAAyB;AACrB,YAAMsD,QAAQ1B,aAAaD,GAAb,EAAkB3B,KAAlB,CAAd;;AAEI;AACJsD,cAAMC,MAAN,GAAe,YAAY;AACvBD,kBAAMxB,KAAN,GAAcJ,OAAd,CAAsB,UAACpB,IAAD,EAAU;AAC5B,oBAAIA,KAAKkD,OAAT,EAAkB;AACdlD,yBAAKkD,OAAL;AACH;AACJ,aAJD;AAKA9C,iBAAK6C,MAAL,CAAYD,KAAZ;AACH,SAPD;;AASA,YAAIlD,QAAQqD,IAAZ,EAAkB;AACd/C,iBAAK+C,IAAL,CAAUH,KAAV;AACH,SAFD,MAEO;AACH5C,iBAAKgD,OAAL,CAAaJ,KAAb;AACH;;AAGD,YAAItD,UAAU,IAAd,EAAoB;AACZ;AACJ2D,uBAAW,YAAM;AACT;AACJL,sBAAMrB,QAAN,CAAe,IAAf;AACA,iBAACqB,MAAMxB,KAAN,MAAiB,EAAlB,EAAsB8B,IAAtB,CAA2B,UAACtD,IAAD,EAAU;AACjC,wBAAIA,KAAKuD,QAAL,MAAmBvD,KAAKwD,QAA5B,EAAsC;AAClCxD,6BAAKwD,QAAL,CAAc,IAAd;AACA,+BAAO,IAAP;AACH;AACD,2BAAO,KAAP;AACH,iBAND;AAOH,aAVD;AAWH;AACJ;;AAEG;AACA;AACA;AACA;AACA;AACJ,aAAS5D,QAAT,GAAoB;AAChB,YAAI6D,WAAW,iBAAErE,SAAF,CAAYgB,OAAOoC,GAAP,CAAW,UAACnB,GAAD,EAAS;AAC3C,gBAAMqC,mBAAmBrC,IAAIpB,cAAJ,CAAmB0D,IAAnB,EAAzB;AACA,mBAAO9B,OAAOC,IAAP,CAAY4B,gBAAZ,EAA8B3B,MAA9B,CAAqC,UAAC6B,OAAD,EAAUC,OAAV,EAAsB;AAC9D,oBAAM7D,OAAOqB,IAAIpB,cAAJ,CAAmB0D,IAAnB,GAA0BE,OAA1B,CAAb;;AAEA,oBAAI7D,QAAQA,KAAKJ,QAAjB,EAA2B;AACvBgE,4BAAQ5D,KAAKV,EAAb,IAAmBU,KAAKJ,QAAL,EAAnB;AACH,iBAFD,MAEO,IAAI,mBAAII,IAAJ,KAAaA,KAAK4C,IAAL,KAAc,QAA/B,EAAyC;AAC5CgB,4BAAQC,OAAR,IAAmB7D,IAAnB;AACH;AACD,uBAAO4D,OAAP;AACH,aATM,EASJ,EATI,CAAP;AAUH,SAZ0B,EAYxBE,MAZwB,CAYjB;AAAA,mBAAO,EAAEhE,QAAQiE,eAAR,IACF,CAACC,IAAIlE,QAAQiE,eAAZ,CAAD,IAAiCC,IAAIlE,QAAQiE,eAAZ,MAAiC,CADlE,CAAP;AAAA,SAZiB,CAAZ,CAAf;AAcA,YAAIjE,QAAQmE,eAAR,IAA2BR,SAASS,MAAT,KAAoB,CAAnD,EAAsD;AAClDT,uBAAW,IAAX;AACH;AACD,eAAOA,QAAP;AACH;;AAED;AACA;AACA,aAASU,UAAT,GAAsB;AAClB;AACA,YAAI1E,UAAU2E,MAAMC,OAAN,CAAc5E,MAAd,CAAV,IAAmCA,OAAOyE,MAAP,GAAgB,CAAvD,EAA0D;AACtD9D,mBAAOgB,OAAP,CAAe,UAACC,GAAD,EAAS;AACpBA,oBAAIG,KAAJ,GAAYJ,OAAZ,CAAoB,UAACpB,IAAD,EAAU;AAC1BA,yBAAKkD,OAAL,IAAgBlD,KAAKkD,OAAL,EAAhB;AACH,iBAFD;AAGH,aAJD;AAKA9C,iBAAKkE,SAAL;AACA7E,mBAAO2B,OAAP,CAAe,UAACpB,IAAD,EAAU;AACrB+C,oBAAI/C,IAAJ,EAAU,KAAV;AACH,aAFD;;AAIA;AACA,gBAAIG,KAAKoE,gBAAT,EAA2B;AACvB,kCAAYC,GAAZ,CAAgBrE,KAAKb,EAArB,EAAyBG,MAAzB;AACH;AACJ,SAfD,MAeO;AACH,iBAAK,IAAIgF,IAAIrE,OAAO8D,MAApB,EAA4BO,IAAI3D,eAAhC,EAAiD2D,GAAjD,EAAsD;AAClD1B,oBAAI,IAAJ,EAAU,IAAV;AACH;AACJ;AACD;AACH;;AAED;AACA;AACA,aAAS7C,QAAT,CAAkBwE,OAAlB,EAA2B;AACvB,YAAI,CAACA,YAAY,IAAZ,IACAN,MAAMC,OAAN,CAAcK,OAAd,KAA0BA,QAAQR,MAAR,KAAmB,CAD9C,KACqDtE,eAAe,IADxE,EAC8E;AAC1E,mBAD0E,CAClE;AACX;AACG;AACJ,YAAIwE,MAAMC,OAAN,CAAcK,OAAd,KAA0B,CAAC5E,QAAQqD,IAAvC,EAA6C;AACzCuB,oBAAQC,OAAR;AACH;AACDlF,aAAKiF,WAAY/D,eAAe,EAAhC;AACAwD;AACH;;AAEG;AACJ,aAASS,OAAT,GAAmB;AACf,eAAOxE,OAAOA,OAAO8D,MAAP,GAAgB,CAAvB,CAAP;AACH;;AAEG;AACJ,QAAI/D,KAAK0E,WAAL,IAAoB1E,KAAK0E,WAAL,CAAiBC,QAAzC,EAAmD;AAC/C,YAAMC,UAAU5E,KAAK0E,WAAL,CAAiBC,QAAjB,CAA0BE,MAA1B,IAAoC7E,KAAK0E,WAAL,CAAiBC,QAArE;AACAhE,0BAAkBiE,YAAY,IAAZ,GAAmB,CAAnB,GAAuBA,OAAzC;;AAEA,YAAI5E,KAAK0E,WAAL,CAAiBC,QAAjB,CAA0B7D,MAA9B,EAAsC;AAClCA,qBAASd,KAAK0E,WAAL,CAAiBC,QAAjB,CAA0B7D,MAAnC;AACH;AACJ;;AAEG;AACJF,uBAAmB,wBAAS,YAAM;AAC9B,YAAIkE,aAAa,IAAjB;AACA,YAAIhE,MAAJ,EAAY;AACRgE,yBAAa,wBAAShE,MAAT,EAAiB/B,QAAQU,QAAzB,CAAb;AACH;AACD,eAAO,CAACqF,UAAD,IACH7E,OAAO0D,MAAP,CAAc;AAAA,mBAAK,CAACoB,EAAElG,UAAH,IAAiB,CAACkG,EAAElG,UAAF,EAAvB;AAAA,SAAd,EAAqDkF,MAArD,GAA8DpD,eADlE;AAEH,KAPkB,CAAnB;;AASI;AACJ,QAAI5B,QAAQO,IAAR,IAAgB,CAACK,QAAQqF,eAA7B,EAA8C;AAC1CxC,gBAAQyC,IAAR,CAAa,2HAAb,EAA0IjF,IAA1I;AACH;AACD,QAAIL,QAAQqF,eAAR,IAA2BjG,QAAQO,IAAvC,EAA6C;AACzC,YAAIP,QAAQO,IAAR,GAAeU,KAAKb,EAApB,CAAJ,EAA6B;AACzBG,iBAAKP,QAAQO,IAAR,GAAeU,KAAKb,EAApB,CAAL;AACH,SAFD,MAEO;AACHJ,oBAAQO,IAAR,CAAa4F,SAAb,CAAuB,UAACX,OAAD,EAAa;AAChC,oBAAIA,QAAQvE,KAAKb,EAAb,CAAJ,EAAsB;AAClBG,yBAAKiF,QAAQvE,KAAKb,EAAb,CAAL;AACA6E;AACH;AACJ,aALD;AAMH;AACJ;;AAEDA;;AAEI;AACA;AACA;AACJ,4BAAS,YAAM;AACX,YAAI9D,SAAJ,EAAe;AACXG,6BAAiBJ,OAAO0D,MAAP,CAAc;AAAA,uBAAO,CAACzC,IAAIrC,UAAJ,EAAR;AAAA,aAAd,CAAjB;AACH,SAFD,MAEO;AACHwB,6BAAiB,EAAjB;AACH;AACJ,KAND;;AAQA,QAAIL,KAAKmF,QAAT,EAAmB;AACflF,aAAKiF,SAAL,CAAe,UAACE,OAAD,EAAa;AACxB7E,wBAAY,CAAC6E,WAAW,EAAZ,EAAgBC,KAAhB,CAAsB,CAAtB,EAAyB,EAAzB,CAAZ;AACH,SAFD;;AAIAxE,mBAAW,kBAAUyE,KAAV,EAAiB;AACxB,gBAAMC,OAAOD,MAAME,MAAnB;AAAA,gBACIC,cAAcxF,MADlB;;AAGA,gBAAIsF,KAAKG,SAAL,GAAkBH,KAAKI,YAAL,GAAoBJ,KAAKK,YAAzB,GAAwC,EAA9D,EAAmE;AAC/D,oBAAMC,OAAOtF,cAAcwD,MAA3B;AACA,qBAAK,IAAIO,IAAI,CAAb,EAAgBA,IAAI,EAApB,EAAwBA,GAAxB,EAA6B;AACzB/D,gCAAYyC,IAAZ,CAAiByC,YAAYI,OAAOvB,CAAnB,CAAjB;;AAEA,wBAAI,CAACmB,YAAYI,OAAOvB,CAAnB,CAAL,EAA4B;AACpB;AACJ;AACH;AACJ;AACJ;AACJ,SAfD;AAgBH;;AAGD,WAAO,qBAAMtE,IAAN,EAAY;AACf4C,aAAKA,GADU;AAEf3C,cAAMD,KAAKmF,QAAL,GAAgB5E,WAAhB,GAA8BN,IAFrB;AAGfN,iBAASA,OAHM;AAIfmG,iBAAS7F,IAJM;AAKfY,kBAAUA,QALK;AAMfR,0BAAkBA,gBANH;AAOfH,iBAASA,OAPM;AAQf6F,oBAAYnF,gBARG;AASfnB,kBAAUA,QATK;AAUfM,kBAAUA,QAVK;AAWfI,kBAAUA,QAXK;AAYfC,oBAAYA,UAZG;AAafqE,iBAASA,OAbM;AAcf1D,qBAAaA,WAdE;AAefN,2BAAmBA;AAfJ,KAAZ,CAAP;AAiBH","file":"listViewModel.js","sourcesContent":["import { observable, observableArray, computed, unwrap } from 'knockout';\r\nimport { createViewModel } from 'scalejs.metadataFactory';\r\nimport { evaluate } from 'scalejs.expression-jsep';\r\nimport noticeboard from 'scalejs.noticeboard';\r\nimport { merge, has, is } from 'scalejs';\r\nimport _ from 'lodash';\r\n\r\n    // todo: revisit comments below\r\n    // listViewModel is a component which manages a simple list\r\n    // - items - items are what are used to make up the rows in the list\r\n    // - options\r\n    // -- addRows - if false add button does not appear\r\n    // -- deleteRows - if false delete button does not appear\r\n    // -- minRequiredRows - initializes list with # of rows and wont let user delete\r\n\r\n    // TODO: Refactor Session\r\n    // - implement \"parent passes to children\" pattern for labels\r\n    // - brainstorm cleaner \"itemViewModel\" imp.\r\n    // - general clean up/renaming/documenting session\r\n    // ...add more refactor session goals here!\r\n    /**\r\n     *  list is the component to use when wanting to group items into enumerable lists.\r\n     *  There are two types of lists:\r\n     * responsive form lists (default) and table lists (+listAdvanced wrapper)\r\n     *  The underlying data model for a list is an array of objects.\r\n     *\r\n     * @module list\r\n     *\r\n     * @param {object} node\r\n     *  The configuration specs for the component.\r\n     * @param {string} [node.id]\r\n     *  The id of the list becomes the key in the data for all the children of the list.\r\n     *\r\n     */\r\nconst listItems = {\r\n    DELETE: del,\r\n    DELETE_FLAG: deleteFlag\r\n};\r\n\r\nfunction del(itemDef) {\r\n    const context = this,\r\n        clonedItem = _.cloneDeep(itemDef);\r\n\r\n    delete clonedItem.template; // prevent scalejs merge issue\r\n\r\n    return merge(clonedItem, {\r\n        id: undefined,\r\n        template: {\r\n            name: itemDef.template || 'list_del_template',\r\n            data: context\r\n        }\r\n    });\r\n}\r\n\r\nfunction deleteFlag(itemDef) {\r\n    const context = this;\r\n        // the id will be the propertu\r\n        // getValue - return if it was deleted or not\r\n    return context.isNew ? del.call(context, itemDef) : merge(context, {\r\n        template: 'list_del_flag_template',\r\n        getValue: function () {\r\n            return context.deleteFlag() ? 'T' : 'F';\r\n        },\r\n        deleteRow: function () {\r\n            context.deleteFlag(true);\r\n            if (itemDef.options && itemDef.options.clearOnDelete) {\r\n                const item = context.itemDictionary()[itemDef.options.clearOnDelete];\r\n                if (item && item.setValue) {\r\n                    item.setValue(0);\r\n                }\r\n            }\r\n        }\r\n    }, itemDef);\r\n}\r\n\r\n\r\nexport default function listViewModel(node) {\r\n    const rows = observableArray(),\r\n        options = node.options || {},\r\n        isShown = observable(true),\r\n        context = this || {},\r\n        // initialize to the context's state as determined by the form generally\r\n        readonly = observable((context.readonly && context.readonly()) || false),\r\n        deleteRows = observable(options.deleteRows !== false),\r\n            // addButtonContext = node.addButtonContext,\r\n        mappedChildNodes = observableArray(),\r\n        data = observable(node.data),\r\n        unique = {},\r\n        visibleRows = observableArray(),\r\n        initialData = _.cloneDeep(node.data) || [],\r\n        addButtonRendered = is(node.addButtonRendered, 'string') ?\r\n                computed(evaluate.bind(null, node.addButtonRendered, context.getValue))\r\n                : observable(node.addButtonRendered !== false);\r\n    let minRequiredRows = 0,\r\n        showRemoveButton = null,\r\n        scrolled,\r\n        onlyIf;\r\n\r\n    function setReadonly(bool) {\r\n        readonly(bool); // sets readonly state of the list\r\n        rows().forEach((row) => { // sets readonly state of each row\r\n            row.readonly(bool);\r\n        });\r\n    }\r\n\r\n        // rowViewModel\r\n        // called on each add\r\n        // or when data is set with initial values\r\n    function rowViewModel(initialValues, isNew) {\r\n        const items = observableArray(), // observable array to hold the items in the row\r\n            // observable dictionary to hold the items and other properties\r\n            itemDictionary = observable({}),\r\n            rowContext = {\r\n                metadata: context.metadata, // reference to the parent metadata\r\n                rows: rows,\r\n                unique: unique,\r\n                isNew: isNew,\r\n                itemDictionary: itemDictionary,\r\n                editMode: observable(false), // for styling - maybe better if called isActiveRow\r\n                deleteFlag: observable(false),\r\n                data: computed(() => {\r\n                    const dict = itemDictionary();\r\n                    return Object.keys(dict).reduce((d, id) => {\r\n                        const item = dict[id];\r\n                        if (item && item.getValue) {\r\n                            d[id] = item.getValue();\r\n                        } else {\r\n                            d[id] = item;\r\n                        }\r\n                        return d;\r\n                    }, {});\r\n                })\r\n            },\r\n            row = {}; // the row itself\r\n        let prop,\r\n            itemViewModels = null,\r\n            rowReadonly;\r\n\r\n            // initialize row readonly as the list's state\r\n        rowContext.readonly = observable(readonly());\r\n\r\n            // rowReadonly - string to run thrown expression parser to show/hide rows\r\n        if (is(options.rowReadonly, 'string')) {\r\n            rowReadonly = computed(() => {\r\n                if (rowContext.readonly && rowContext.readonly()) {\r\n                    return true; // if readonly is true on context, then row is readonly\r\n                }\r\n                    // else, eval the expression to determine if the row is readonly\r\n                return evaluate(options.rowReadonly, (id) => {\r\n                    const item = itemDictionary()[id];\r\n                    if (item && item.getValue) {\r\n                        return item.getValue();\r\n                    }\r\n                });\r\n            });\r\n        }\r\n\r\n            // can be utilized by expression parser to get error for an id\r\n        function error(id) {\r\n            const item = itemDictionary()[id];\r\n            if (item && item.inputValue && item.inputValue.error) {\r\n                return item.inputValue.error();\r\n            }\r\n        }\r\n\r\n            // accurately calculates the index of the row in the list\r\n        rowContext.index = computed(() => rows().indexOf(row));\r\n\r\n            // getValueById function for expression parsing\r\n            // todo. refactor this\r\n        rowContext.getValue = function (id) {\r\n            if (id === 'index') {\r\n                return rowContext.index();\r\n            }\r\n            if (id === 'list') {\r\n                return rows();\r\n            }\r\n            if (id === 'row') {\r\n                return rows()[rowContext.index()];\r\n            }\r\n            if (id === 'error') {\r\n                return error;\r\n            }\r\n                // check the item dictionary\r\n            const item = itemDictionary()[id];\r\n            if (item && item.getValue) {\r\n                return item.getValue();\r\n            }\r\n\r\n                // if the item doesnt have getValue, return itself\r\n            if (has(item)) {\r\n                return unwrap(item);\r\n            }\r\n\r\n            prop = rowContext[id];\r\n\r\n            if (has(prop)) {\r\n                return unwrap(prop);\r\n            }\r\n\r\n            return context.getValue(id);\r\n        };\r\n\r\n\r\n        itemViewModels = node.items.map((_item) => {\r\n            // deep clone the item as we might mutate it before passing to createViewModels\r\n            const item = _.cloneDeep(_item);\r\n\r\n                // add readonly computed to the item before passing it to input\r\n                // input will use the already defined observable if it exists\r\n                // but, if the input already has readonly set on it, dont get readonly from row..\r\n            if (rowReadonly && item.input && !has(item.input.readonly)) {\r\n                item.input.readonly = rowReadonly;\r\n            }\r\n\r\n            if (item.options && item.options.unique) {\r\n                if (!item.id) {\r\n                    console.error('Cannot set unique on item without id');\r\n                } else if (!unique[item.id]) { // only create once\r\n                    unique[item.id] = observableArray();\r\n                }\r\n            }\r\n\r\n                // todo - clean this up?\r\n            if (listItems[item.type]) {\r\n                const ret = listItems[item.type].call(rowContext, item);\r\n                if (item.visible) {\r\n                    ret.visible = computed(() => evaluate(item.visible, rowContext.getValue));\r\n                }\r\n                return ret;\r\n            }\r\n            return createViewModel.call(rowContext, item);\r\n        });\r\n\r\n            // if there are initial values, update the children\r\n        if (initialValues) {\r\n            itemViewModels.forEach((item) => {\r\n                // allow for JSON default values don't get overwritten\r\n                // by server data that doesn't contain data\r\n                if (initialValues[item.id]) {\r\n                    item.setValue && item.setValue(initialValues[item.id]);\r\n                }\r\n            });\r\n        }\r\n\r\n            // update items obsArr\r\n        items(itemViewModels);\r\n\r\n            // generate itemDictionary from the itemViewModels\r\n            // also add each item's inputValue directly on the row\r\n            // this is for MemberExpressions to work properly (list[0].Status)\r\n        itemDictionary(itemViewModels.reduce((dict, item) => {\r\n            if (has(item.id)) {\r\n                dict[item.id] = item;\r\n                row[item.id] = item.inputValue;\r\n            }\r\n            return dict;\r\n        }, merge(initialValues || {})));\r\n        // just in case some data doesnt have a column, keep it in the item dict\r\n\r\n        // TODO: ItemDict or Row? which one is better?\r\n        // rowVM\r\n        row.items = items;\r\n        row.itemDictionary = itemDictionary;\r\n        row.mappedChildNodes = items;\r\n        row.editMode = rowContext.editMode;\r\n        row.deleteFlag = rowContext.deleteFlag;\r\n        row.readonly = function (bool) {\r\n            items().forEach((item) => {\r\n                if (item.setReadonly) {\r\n                    item.setReadonly(bool);\r\n                } else if (item.readonly) {\r\n                    item.readonly(bool);\r\n                }\r\n            });\r\n        };\r\n\r\n        return row;\r\n    }\r\n\r\n        // generates a new row and add to list\r\n    function add(row, isNew) {\r\n        const rowVm = rowViewModel(row, isNew);\r\n\r\n            // add remove function to rowVM\r\n        rowVm.remove = function () {\r\n            rowVm.items().forEach((item) => {\r\n                if (item.dispose) {\r\n                    item.dispose();\r\n                }\r\n            });\r\n            rows.remove(rowVm);\r\n        };\r\n\r\n        if (options.push) {\r\n            rows.push(rowVm);\r\n        } else {\r\n            rows.unshift(rowVm);\r\n        }\r\n\r\n\r\n        if (isNew === true) {\r\n                // auto-focus on the newly added row\r\n            setTimeout(() => {\r\n                    // need to wait for clickOff events to stop firing.\r\n                rowVm.editMode(true);\r\n                (rowVm.items() || []).some((item) => {\r\n                    if (item.rendered() && item.hasFocus) {\r\n                        item.hasFocus(true);\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n        // returns the values of the list\r\n        // e.g. [{item1:'Value1',item2:'Value2'}]\r\n        // dontSendIfEmpty - this prevents items from getting\r\n        // sent in the data if that property is empty\r\n        // if array is empty send null\r\n    function getValue() {\r\n        let listData = _.cloneDeep(rows().map((row) => {\r\n            const originalRowItems = row.itemDictionary.peek();\r\n            return Object.keys(originalRowItems).reduce((dataObj, itemKey) => {\r\n                const item = row.itemDictionary.peek()[itemKey];\r\n\r\n                if (item && item.getValue) {\r\n                    dataObj[item.id] = item.getValue();\r\n                } else if (has(item) && item.type !== 'DELETE') {\r\n                    dataObj[itemKey] = item;\r\n                }\r\n                return dataObj;\r\n            }, {});\r\n        }).filter(obj => !(options.dontSendIfEmpty &&\r\n                        (!obj[options.dontSendIfEmpty] && obj[options.dontSendIfEmpty] !== 0))));\r\n        if (options.sendNullIfEmpty && listData.length === 0) {\r\n            listData = null;\r\n        }\r\n        return listData;\r\n    }\r\n\r\n    // on initialization if the node already has data defined, add rows\r\n    // else generate the minReqiredRows\r\n    function initialize() {\r\n        // console.time('List init');\r\n        if (data() && Array.isArray(data()) && data().length > 0) {\r\n            rows().forEach((row) => {\r\n                row.items().forEach((item) => {\r\n                    item.dispose && item.dispose();\r\n                });\r\n            });\r\n            rows.removeAll();\r\n            data().forEach((item) => {\r\n                add(item, false);\r\n            });\r\n\r\n            // if trackDiffChanges set to true store the original data to noticeboard\r\n            if (node.trackDiffChanges) {\r\n                noticeboard.set(node.id, data());\r\n            }\r\n        } else {\r\n            for (let i = rows().length; i < minRequiredRows; i++) {\r\n                add(null, true);\r\n            }\r\n        }\r\n        //  console.timeEnd('List init');\r\n    }\r\n\r\n    // sets value in list\r\n    // or re-inits if data is empty or invalid\r\n    function setValue(newData) {\r\n        if ((newData === null ||\r\n            (Array.isArray(newData) && newData.length === 0)) && getValue() === null) {\r\n            return; // new data is same as current one (empty array)\r\n        }\r\n            // reverse the data because adding now unshifts the rows.\r\n        if (Array.isArray(newData) && !options.push) {\r\n            newData.reverse();\r\n        }\r\n        data(newData || (initialData || []));\r\n        initialize();\r\n    }\r\n\r\n        // returns last row\r\n    function lastRow() {\r\n        return rows()[rows().length - 1];\r\n    }\r\n\r\n        // sets minrequired rows\r\n    if (node.validations && node.validations.required) {\r\n        const minRows = node.validations.required.params || node.validations.required;\r\n        minRequiredRows = minRows === true ? 1 : minRows;\r\n\r\n        if (node.validations.required.onlyIf) {\r\n            onlyIf = node.validations.required.onlyIf;\r\n        }\r\n    }\r\n\r\n        // only show remove button if rows is greater than min req rows\r\n    showRemoveButton = computed(() => {\r\n        let isRequired = true;\r\n        if (onlyIf) {\r\n            isRequired = evaluate(onlyIf, context.getValue);\r\n        }\r\n        return !isRequired ||\r\n            rows().filter(r => !r.deleteFlag || !r.deleteFlag()).length > minRequiredRows;\r\n    });\r\n\r\n        // get data from data parent if exists\r\n    if (context.data && !options.subscribeToData) {\r\n        console.warn('Please make sure you get the Data from setValue or set node.subscribeToData to true! Removing data-subscribe as a default', node);\r\n    }\r\n    if (options.subscribeToData && context.data) {\r\n        if (context.data()[node.id]) {\r\n            data(context.data()[node.id]);\r\n        } else {\r\n            context.data.subscribe((newData) => {\r\n                if (newData[node.id]) {\r\n                    data(newData[node.id]);\r\n                    initialize();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    initialize();\r\n\r\n        // will \"remove\" mapped child nodes if the list is hidden\r\n        // this is required for validations to work properly\r\n        // todo: remove this workaround and implement validation on list itself\r\n    computed(() => {\r\n        if (isShown()) {\r\n            mappedChildNodes(rows().filter(row => !row.deleteFlag()));\r\n        } else {\r\n            mappedChildNodes([]);\r\n        }\r\n    });\r\n\r\n    if (node.infinite) {\r\n        rows.subscribe((newRows) => {\r\n            visibleRows((newRows || []).slice(0, 20));\r\n        });\r\n\r\n        scrolled = function (event) {\r\n            const elem = event.target,\r\n                currentRows = rows();\r\n\r\n            if (elem.scrollTop > (elem.scrollHeight - elem.offsetHeight - 35)) {\r\n                const seed = visibleRows().length;\r\n                for (let i = 0; i < 20; i++) {\r\n                    visibleRows.push(currentRows[seed + i]);\r\n\r\n                    if (!currentRows[seed + i]) {\r\n                            // no more rows stahp\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n\r\n    return merge(node, {\r\n        add: add,\r\n        rows: node.infinite ? visibleRows : rows,\r\n        options: options,\r\n        allRows: rows,\r\n        scrolled: scrolled,\r\n        mappedChildNodes: mappedChildNodes,\r\n        isShown: isShown,\r\n        showRemove: showRemoveButton,\r\n        getValue: getValue,\r\n        setValue: setValue,\r\n        readonly: readonly,\r\n        deleteRows: deleteRows,\r\n        lastRow: lastRow,\r\n        setReadonly: setReadonly,\r\n        addButtonRendered: addButtonRendered\r\n    });\r\n}"]}