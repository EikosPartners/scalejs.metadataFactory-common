{"version":3,"sources":["../../src/list/listViewModel.js"],"names":["listViewModel","listItems","DELETE","del","DELETE_FLAG","deleteFlag","itemDef","context","clonedItem","_","cloneDeep","template","id","undefined","name","data","isNew","call","getValue","deleteRow","options","clearOnDelete","item","itemDictionary","setValue","node","rows","isShown","readonly","deleteRows","mappedChildNodes","unique","visibleRows","initialData","addButtonRendered","evaluate","bind","initial","nodeDataAsInitial","minRequiredRows","showRemoveButton","sub","scrolled","onlyIf","setReadonly","bool","forEach","row","rowViewModel","initialValues","initialOverride","items","rowContext","metadata","editMode","dict","extend","Object","keys","reduce","d","prop","itemViewModels","rowReadonly","error","inputValue","index","indexOf","value","peek","map","_item","input","console","type","ret","visible","optimize","createViewModel","add","rowVm","remove","dispose","push","unshift","focusNew","setTimeout","some","rendered","hasFocus","listData","originalRowItems","dataObj","itemKey","filter","dontSendIfEmpty","obj","sendNullIfEmpty","length","initialize","ko","deferUpdates","removeAll","Array","isArray","trackDiffChanges","noticeboard","set","i","newData","reverse","update","info","lastRow","validations","required","minRows","params","isRequired","r","subscribeToData","warn","subscribe","infinite","newRows","slice","event","elem","target","currentRows","scrollTop","scrollHeight","offsetHeight","seed","allRows","showRemove"],"mappings":"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","file":"listViewModel.js","sourcesContent":["import { observable, observableArray, computed, unwrap } from 'knockout';\nimport { createViewModel } from 'scalejs.metadataFactory';\nimport { evaluate } from 'scalejs.expression-jsep';\nimport noticeboard from 'scalejs.noticeboard';\nimport { merge, has, is } from 'scalejs';\nimport _ from 'lodash';\nimport ko from 'knockout';\n\n// todo: revisit comments below\n// listViewModel is a component which manages a simple list\n// - items - items are what are used to make up the rows in the list\n// - options\n// -- addRows - if false add button does not appear\n// -- deleteRows - if false delete button does not appear\n// -- minRequiredRows - initializes list with # of rows and wont let user delete\n\n// TODO: Refactor Session\n// - implement \"parent passes to children\" pattern for labels\n// - brainstorm cleaner \"itemViewModel\" imp.\n// - general clean up/renaming/documenting session\n// ...add more refactor session goals here!\n/**\n *  list is the component to use when wanting to group items into enumerable lists.\n *  There are two types of lists:\n * responsive form lists (default) and table lists (+listAdvanced wrapper)\n *  The underlying data model for a list is an array of objects.\n *\n * @module list\n *\n * @param {object} node\n *  The configuration specs for the component.\n * @param {string} [node.id]\n *  The id of the list becomes the key in the data for all the children of the list.\n *\n */\nconst listItems = {\n    DELETE: del,\n    DELETE_FLAG: deleteFlag\n};\n\nfunction del(itemDef) {\n    const context = this,\n        clonedItem = _.cloneDeep(itemDef);\n\n    delete clonedItem.template; // prevent scalejs merge issue\n\n    return merge(clonedItem, {\n        id: undefined,\n        template: {\n            name: itemDef.template || 'list_del_template',\n            data: context\n        }\n    });\n}\n\nfunction deleteFlag(itemDef) {\n    const context = this;\n    // the id will be the propertu\n    // getValue - return if it was deleted or not\n    return context.isNew ? del.call(context, itemDef) : merge(context, {\n        template: 'list_del_flag_template',\n        getValue: function () {\n            return context.deleteFlag() ? 'T' : 'F';\n        },\n        deleteRow: function () {\n            context.deleteFlag(true);\n            if (itemDef.options && itemDef.options.clearOnDelete) {\n                const item = context.itemDictionary()[itemDef.options.clearOnDelete];\n                if (item && item.setValue) {\n                    item.setValue(0);\n                }\n            }\n        }\n    }, itemDef);\n}\n\n\nexport default function listViewModel(node) {\n    const rows = observableArray(),\n        options = node.options || {},\n        isShown = observable(true),\n        context = this || {},\n        // initialize to the context's state as determined by the form generally\n        readonly = observable((context.readonly && context.readonly()) || false),\n        deleteRows = observable(options.deleteRows !== false),\n        // addButtonContext = node.addButtonContext,\n        mappedChildNodes = observableArray(),\n        data = observable(node.data),\n        unique = {},\n        visibleRows = observableArray(),\n        initialData = _.cloneDeep(node.data) || [],\n        addButtonRendered = is(node.addButtonRendered, 'string') ?\n            computed(evaluate.bind(null, node.addButtonRendered, context.getValue))\n            : observable(node.addButtonRendered !== false);\n    let initial = node.nodeDataAsInitial !== false,\n        minRequiredRows = 0,\n        showRemoveButton = null,\n        sub = null,\n        scrolled,\n        onlyIf;\n\n    function setReadonly(bool) {\n        readonly(bool); // sets readonly state of the list\n        rows().forEach((row) => { // sets readonly state of each row\n            row.readonly(bool);\n        });\n    }\n\n    // rowViewModel\n    // called on each add\n    // or when data is set with initial values\n    function rowViewModel(initialValues, isNew, initialOverride) {\n        const items = observableArray(), // observable array to hold the items in the row\n            // observable dictionary to hold the items and other properties\n            itemDictionary = observable({}),\n            rowContext = {\n                metadata: context.metadata, // reference to the parent metadata\n                rows: rows,\n                unique: unique,\n                isNew: isNew,\n                itemDictionary: itemDictionary,\n                editMode: observable(false), // for styling - maybe better if called isActiveRow\n                deleteFlag: observable(false),\n                data: computed(() => {\n                    const dict = itemDictionary();\n                    return _.extend({}, initialValues || {}, Object.keys(dict).reduce((d, id) => {\n                        const item = dict[id];\n                        if (item && item.getValue) {\n                            d[id] = item.getValue();\n                        } else {\n                            d[id] = item;\n                        }\n                        return d;\n                    }, {}));\n                })\n            },\n            row = {}; // the row itself\n        let prop,\n            itemViewModels = null,\n            rowReadonly;\n\n        // initialize row readonly as the list's state\n        rowContext.readonly = observable(readonly());\n\n        // rowReadonly - string to run thrown expression parser to show/hide rows\n        if (is(options.rowReadonly, 'string')) {\n            rowReadonly = computed(() => {\n                if (rowContext.readonly && rowContext.readonly()) {\n                    return true; // if readonly is true on context, then row is readonly\n                }\n                // else, eval the expression to determine if the row is readonly\n                return evaluate(options.rowReadonly, (id) => {\n                    const item = itemDictionary()[id];\n                    if (item && item.getValue) {\n                        return item.getValue();\n                    }\n                });\n            });\n        }\n\n        // can be utilized by expression parser to get error for an id\n        function error(id) {\n            const item = itemDictionary()[id];\n            if (item && item.inputValue && item.inputValue.error) {\n                return item.inputValue.error();\n            }\n        }\n\n        // accurately calculates the index of the row in the list\n        rowContext.index = computed(() => rows().indexOf(row));\n\n        // getValueById function for expression parsing\n        // todo. refactor this\n        rowContext.getValue = function (id) {\n            if (id === 'index') {\n                return rowContext.index();\n            }\n            if (id === 'list') {\n                return rows();\n            }\n            if (id === 'row') {\n                return rows()[rowContext.index()];\n            }\n            if (id === 'error') {\n                return error;\n            }\n            if (id === 'parent') {\n                return context.data();\n            }\n            // check the item dictionary\n            const item = itemDictionary()[id];\n            if (item && item.getValue) {\n                return item.getValue();\n            }\n\n            // if the item doesnt have getValue, return itself\n            if (has(item)) {\n                return unwrap(item);\n            }\n\n            const value = rowContext.data.peek()[id];\n            if (has(value)) {\n                return value;\n            }\n\n            prop = rowContext[id];\n\n            if (has(prop)) {\n                return unwrap(prop);\n            }\n\n            return context.getValue(id);\n        };\n\n\n        itemViewModels = node.items.map((_item) => {\n            // deep clone the item as we might mutate it before passing to createViewModels\n            const item = _.cloneDeep(_item);\n\n            // add readonly computed to the item before passing it to input\n            // input will use the already defined observable if it exists\n            // but, if the input already has readonly set on it, dont get readonly from row..\n            if (rowReadonly && item.input && !has(item.input.readonly)) {\n                item.input.readonly = rowReadonly;\n            }\n\n            if (item.options && item.options.unique) {\n                if (!item.id) {\n                    console.error('Cannot set unique on item without id');\n                } else if (!unique[item.id]) { // only create once\n                    unique[item.id] = observableArray();\n                }\n            }\n\n            // todo - clean this up?\n            if (listItems[item.type]) {\n                const ret = listItems[item.type].call(rowContext, item);\n                if (item.visible) {\n                    ret.visible = computed(() => evaluate(item.visible, rowContext.getValue));\n                }\n                return ret;\n            }\n            if (options.optimize && initialValues) {\n                item.options = item.options || {};\n                item.options.value = initialValues[item.id];\n            }\n            return createViewModel.call(rowContext, item);\n        });\n\n        // if there are initial values, update the children\n        if (initialValues && !options.optimize) {\n            itemViewModels.forEach((item) => {\n                // allow for JSON default values don't get overwritten\n                // by server data that doesn't contain data\n                if (initialValues[item.id]) {\n                    item.setValue && item.setValue(initialValues[item.id], { initial: initialOverride !== false });\n                }\n            });\n        }\n\n        // update items obsArr\n        items(itemViewModels);\n\n        // generate itemDictionary from the itemViewModels\n        // also add each item's inputValue directly on the row\n        // this is for MemberExpressions to work properly (list[0].Status)\n        itemDictionary(itemViewModels.reduce((dict, item) => {\n            if (has(item.id)) {\n                dict[item.id] = item;\n                row[item.id] = item.inputValue;\n            }\n            return dict;\n        }, merge(initialValues || {})));\n        // just in case some data doesnt have a column, keep it in the item dict\n\n        // TODO: ItemDict or Row? which one is better?\n        // rowVM\n        row.items = items;\n        row.itemDictionary = itemDictionary;\n        row.mappedChildNodes = items;\n        row.editMode = rowContext.editMode;\n        row.deleteFlag = rowContext.deleteFlag;\n        row.readonly = function (bool) {\n            items().forEach((item) => {\n                if (item.setReadonly) {\n                    item.setReadonly(bool);\n                } else if (item.readonly) {\n                    item.readonly(bool);\n                }\n            });\n        };\n\n        return row;\n    }\n\n    // generates a new row and add to list\n    function add(row, isNew, initialOverride) {\n        const rowVm = rowViewModel(row, isNew, initialOverride);\n\n        // add remove function to rowVM\n        rowVm.remove = function () {\n            rowVm.items().forEach((item) => {\n                if (item.dispose) {\n                    item.dispose();\n                }\n            });\n            rows.remove(rowVm);\n        };\n\n        if (options.push) {\n            rows.push(rowVm);\n        } else {\n            rows.unshift(rowVm);\n        }\n\n\n        if (isNew === true && options.focusNew !== false) {\n            // auto-focus on the newly added row\n            setTimeout(() => {\n                // need to wait for clickOff events to stop firing.\n                rowVm.editMode(true);\n                (rowVm.items() || []).some((item) => {\n                    if (item.rendered() && item.hasFocus) {\n                        item.hasFocus(true);\n                        return true;\n                    }\n                    return false;\n                });\n            });\n        }\n    }\n\n    // returns the values of the list\n    // e.g. [{item1:'Value1',item2:'Value2'}]\n    // dontSendIfEmpty - this prevents items from getting\n    // sent in the data if that property is empty\n    // if array is empty send null\n    function getValue() {\n        let listData = _.cloneDeep(rows().map((row) => {\n            const originalRowItems = row.itemDictionary.peek();\n            return Object.keys(originalRowItems).reduce((dataObj, itemKey) => {\n                const item = row.itemDictionary.peek()[itemKey];\n\n                if (item && item.getValue) {\n                    dataObj[item.id] = item.getValue();\n                } else if (has(item) && item.type !== 'DELETE') {\n                    dataObj[itemKey] = item;\n                }\n                return dataObj;\n            }, {});\n        }).filter(obj => !(options.dontSendIfEmpty &&\n            (!obj[options.dontSendIfEmpty] && obj[options.dontSendIfEmpty] !== 0))));\n        if (options.sendNullIfEmpty && listData.length === 0) {\n            listData = null;\n        }\n        return listData;\n    }\n\n    // on initialization if the node already has data defined, add rows\n    // else generate the minReqiredRows\n    function initialize() {\n        // console.time('List init');\n        if (options.optimize) {\n            ko.options.deferUpdates = true;\n        }\n        rows().forEach((row) => {\n            row.items().forEach((item) => {\n                item.dispose && item.dispose();\n            });\n        });\n        rows.removeAll();\n        if (data() && Array.isArray(data()) && data().length > 0) {\n            data().forEach((item) => {\n                add(item, false, initial);\n            });\n\n            // if trackDiffChanges set to true store the original data to noticeboard\n            if (node.trackDiffChanges) {\n                noticeboard.set(node.id, data());\n            }\n        } else {\n            for (let i = rows().length; i < minRequiredRows; i++) {\n                add(null, true, initial);\n            }\n        }\n        initial = undefined;\n        if (options.optimize) {\n            ko.options.deferUpdates = false;\n        }\n        //  console.timeEnd('List init');\n    }\n\n    // sets value in list\n    // or re-inits if data is empty or invalid\n    function setValue(newData) {\n        if ((newData === null ||\n            (Array.isArray(newData) && newData.length === 0)) && getValue() === null) {\n            return; // new data is same as current one (empty array)\n        }\n        // reverse the data because adding now unshifts the rows.\n        if (Array.isArray(newData) && !options.push) {\n            newData.reverse();\n        }\n        data(newData || (initialData || []));\n        initialize();\n    }\n\n    function update(value) {\n        console.info('List only supports udate for value');\n        setValue(value);\n    }\n\n    // returns last row\n    function lastRow() {\n        return rows()[rows().length - 1];\n    }\n\n    // sets minrequired rows\n    if (node.validations && node.validations.required) {\n        const minRows = node.validations.required.params || node.validations.required;\n        minRequiredRows = minRows === true ? 1 : minRows;\n\n        if (node.validations.required.onlyIf) {\n            onlyIf = node.validations.required.onlyIf;\n        }\n    } else if (node.data) {\n        minRequiredRows = node.data.length;\n    }\n\n    // only show remove button if rows is greater than min req rows\n    showRemoveButton = computed(() => {\n        let isRequired = true;\n        if (onlyIf) {\n            isRequired = evaluate(onlyIf, context.getValue);\n        }\n        return !isRequired ||\n            rows().filter(r => !r.deleteFlag || !r.deleteFlag()).length > minRequiredRows;\n    });\n\n    // get data from data parent if exists\n    if (context.data && !options.subscribeToData) {\n        console.warn('Please make sure you get the Data from setValue or set node.subscribeToData to true! Removing data-subscribe as a default', node);\n    }\n    if (options.subscribeToData && context.data) {\n        if (context.data()[node.id]) {\n            data(context.data()[node.id]);\n        } else {\n            context.data.subscribe((newData) => {\n                if (newData[node.id]) {\n                    data(newData[node.id]);\n                    initialize();\n                }\n            });\n        }\n    }\n\n    initialize();\n\n    // will \"remove\" mapped child nodes if the list is hidden\n    // this is required for validations to work properly\n    // todo: remove this workaround and implement validation on list itself\n    sub = computed(() => {\n        let rendered = true;\n        if (node.rendered) {\n            rendered = evaluate(node.rendered, context.getValue);\n        }\n        if (isShown() && rendered) {\n            mappedChildNodes(rows().filter(row => !row.deleteFlag()));\n        } else {\n            mappedChildNodes([]);\n        }\n    });\n\n    if (node.infinite) {\n        rows.subscribe((newRows) => {\n            visibleRows((newRows || []).slice(0, 20));\n        });\n\n        scrolled = function (event) {\n            const elem = event.target,\n                currentRows = rows();\n\n            if (elem.scrollTop > (elem.scrollHeight - elem.offsetHeight - 35)) {\n                const seed = visibleRows().length;\n                for (let i = 0; i < 20; i++) {\n                    visibleRows.push(currentRows[seed + i]);\n\n                    if (!currentRows[seed + i]) {\n                        // no more rows stahp\n                        break;\n                    }\n                }\n            }\n        };\n    }\n\n\n    return merge(node, {\n        add: add,\n        rows: node.infinite ? visibleRows : rows,\n        options: options,\n        allRows: rows,\n        scrolled: scrolled,\n        mappedChildNodes: mappedChildNodes,\n        isShown: isShown,\n        showRemove: showRemoveButton,\n        getValue: getValue,\n        setValue: setValue,\n        readonly: readonly,\n        deleteRows: deleteRows,\n        lastRow: lastRow,\n        setReadonly: setReadonly,\n        addButtonRendered: addButtonRendered,\n        update: update,\n        dispose() {\n            sub.dispose();\n        }\n    });\n}"]}