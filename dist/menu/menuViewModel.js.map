{"version":3,"sources":["../../src/menu/menuViewModel.js"],"names":["node","keyMap","context","base","call","type","mappedChildNodes","accordion","mapToAccordion","data","sections","map","section","title","unzip","zipped","children","isShown","options","trueAccordion","openByDefault","template","mapWorkflow","workflow","resultsKey","openPanel","openFirst","firstSection","visible","dataSourceEndpoint","subscribe"],"mappings":";;;;;;;;kBAMmB,UAAUA,IAAV,EAAgB;AAC3B,QAAIC,SAASD,KAAKC,MAAL,IAAe,EAA5B;AAAA,QACIC,UAAU,IADd;AAAA,QAEIC,OAAO,yBAAgBC,IAAhB,CAAqB,IAArB,EAA2B,qBAAMJ,IAAN,EAAY,EAAEK,MAAM,UAAR,EAAZ,CAA3B,CAFX;AAAA,QAGIC,mBAAmB,gCAHvB;AAAA,QAIIC,SAJJ;;AAMA,aAASC,cAAT,CAAwBC,IAAxB,EAA8B;AAC1B,YAAI,CAACA,KAAKC,QAAV,EAAoB;AAChB,mBAAO;AACH,wBAAQ,UADL;AAEH,4BAAY;AAFT,aAAP;AAIH;;AAEG,qBAASD,KAAKC,QAAL,CAAcC,GAAd,CAAkB,mBAAW;AAClC,mBAAO,CACHC,QAAQC,KADL,EAEHL,eAAeI,OAAf,CAFG,CAAP;AAIH,SALQ,CAAT;AAAA,sBAMuB,iBAAEE,KAAF,CAAQC,MAAR,CANvB;AAAA;AAAA,YAMCL,QAND;AAAA,YAMWM,QANX;;;AAQJ,eAAO;AACHX,kBAAM,WADH;AAEHY,qBAAS,0BAAW,IAAX,CAFN;AAGH;AACA;AACAC,qBAAS;AACLC,+BAAe,IADV;AAELC,+BAAe;AAFV,aALN;AASHC,sBAAU,gBATP;AAUHX,8BAVG;AAWHM;AAXG,SAAP;AAaH;;AAED,aAASM,WAAT,CAAqBb,IAArB,EAA2B;AACvB,YAAIc,WAAW,mBAAId,IAAJ,EAAUR,OAAOuB,UAAP,IAAqB,EAA/B,EAAmCf,IAAnC,CAAf;AACA;AACAF,oBAAY,yBAAgBH,IAAhB,CAAqBF,OAArB,EAA8BM,eAAee,QAAf,CAA9B,CAAZ;AACAjB,yBAAiB,CAACC,SAAD,CAAjB;;AAEA,YAAI,CAACgB,SAASE,SAAd,EAAyB;AACrBC,sBAAUnB,SAAV;AACH;AACJ;;AAED,aAASmB,SAAT,CAAmBnB,SAAnB,EAA8B;AAC1B,YAAIoB,eAAepB,UAAUG,QAAV,IAAsBH,UAAUG,QAAV,CAAmB,CAAnB,CAAzC;AACA,YAAG,CAACiB,YAAJ,EAAkB;AACd,mBADc,CACN;AACX;AACDA,qBAAaC,OAAb,CAAqB,IAArB;AACAF,kBAAUC,YAAV;AACH;;AAED,QAAG3B,KAAKS,IAAR,EAAc;AACV;AACAa,oBAAYnB,KAAKM,IAAL,EAAZ;AACH,KAHD,MAGO,IAAIT,KAAK6B,kBAAT,EAA6B;AAChC;AACA1B,aAAKM,IAAL,CAAUqB,SAAV,CAAoB,gBAAQ;AACxBR,wBAAYb,IAAZ;AACH,SAFD;AAGH;;AAED,WAAO,qBAAMT,IAAN,EAAY;AACfM;AADe,KAAZ,CAAP;AAGH,C;;AA7EL;;AACA;;AACA;;AACA;;AACA;;;;;;AAyEK","file":"menuViewModel.js","sourcesContent":["import { createViewModels, createViewModel } from 'scalejs.metadataFactory';\nimport { unwrap, computed, observable, observableArray } from 'knockout';\nimport { receive } from 'scalejs.messagebus';\nimport { merge, get } from 'scalejs';\nimport _ from 'lodash';\n\n    export default function (node) {\n        var keyMap = node.keyMap || {},\n            context = this,\n            base = createViewModel.call(this, merge(node, { type: 'template' })),\n            mappedChildNodes = observableArray(),\n            accordion;\n\n        function mapToAccordion(data) {\n            if (!data.sections) {\n                return {\n                    \"type\": \"template\",\n                    \"template\": \"empty_panel\",\n                }\n            }\n\n            let zipped = data.sections.map(section => {\n                    return [\n                        section.title,\n                        mapToAccordion(section)\n                    ]\n                }),\n                [sections, children] = _.unzip(zipped);\n            \n            return {\n                type: 'accordion',\n                isShown: observable(true),\n                // keep all menu items \"closed\" by default\n                // only allow one open menu at a time\n                options: {\n                    trueAccordion: true,\n                    openByDefault: false\n                },\n                template: 'menu_accordion',\n                sections,\n                children\n            }\n        }\n\n        function mapWorkflow(data) {\n            var workflow = get(data, keyMap.resultsKey || '', data);\n            // data will be converted to metadata in order to render accordions\n            accordion = createViewModel.call(context, mapToAccordion(workflow))\n            mappedChildNodes([accordion]);\n            \n            if (!workflow.openPanel) {\n                openFirst(accordion);\n            }\n        }        \n\n        function openFirst(accordion) {\n            let firstSection = accordion.sections && accordion.sections[0];\n            if(!firstSection) {\n                return; // all done opening accordions\n            }\n            firstSection.visible(true);\n            openFirst(firstSection);\n        }\n\n        if(node.data) {            \n            // data loaded synchronously \n            mapWorkflow(base.data());\n        } else if (node.dataSourceEndpoint) {\n            // data loaded asynchronously\n            base.data.subscribe(data => {\n                mapWorkflow(data);\n            });\n        }\n        \n        return merge(node, {\n            mappedChildNodes\n        });\n    };\n"]}