{"version":3,"sources":["../../src/menu/menuViewModel.js"],"names":[],"mappings":";;;;;;;;kBAMmB,UAAU,IAAV,EAAgB;AAC3B,QAAI,SAAS,KAAK,MAAL,IAAe,EAA5B;AAAA,QACI,UAAU,IADd;AAAA,QAEI,OAAO,yBAAgB,IAAhB,CAAqB,IAArB,EAA2B,qBAAM,IAAN,EAAY,EAAE,MAAM,UAAR,EAAZ,CAA3B,CAFX;AAAA,QAGI,mBAAmB,gCAHvB;AAAA,QAII,SAJJ;;AAMA,aAAS,cAAT,CAAwB,IAAxB,EAA8B;AAC1B,YAAI,CAAC,KAAK,QAAV,EAAoB;AAChB,mBAAO;AACH,wBAAQ,UADL;AAEH,4BAAY;AAFT,aAAP;AAIH;;AAEG,qBAAS,KAAK,QAAL,CAAc,GAAd,CAAkB,mBAAW;AAClC,mBAAO,CACH,QAAQ,KADL,EAEH,eAAe,OAAf,CAFG,CAAP;AAIH,SALQ,CAAT;;AARsB,sBAcC,iBAAE,KAAF,CAAQ,MAAR,CAdD;;AAAA;;AAAA,YAcrB,QAdqB;AAAA,YAcX,QAdW;;;AAgB1B,eAAO;AACH,kBAAM,WADH;AAEH,qBAAS,0BAAW,IAAX,CAFN;AAGH;AACA;AACA,qBAAS;AACL,+BAAe,IADV;AAEL,+BAAe;AAFV,aALN;AASH,sBAAU,gBATP;AAUH,8BAVG;AAWH;AAXG,SAAP;AAaH;;AAED,aAAS,WAAT,CAAqB,IAArB,EAA2B;AACvB,YAAI,WAAW,mBAAI,IAAJ,EAAU,OAAO,UAAP,IAAqB,EAA/B,EAAmC,IAAnC,CAAf;AACA;AACA,oBAAY,yBAAgB,IAAhB,CAAqB,OAArB,EAA8B,eAAe,QAAf,CAA9B,CAAZ;AACA,yBAAiB,CAAC,SAAD,CAAjB;;AAEA,YAAI,CAAC,SAAS,SAAd,EAAyB;AACrB,sBAAU,SAAV;AACH;AACJ;;AAED,aAAS,SAAT,CAAmB,SAAnB,EAA8B;AAC1B,YAAI,eAAe,UAAU,QAAV,IAAsB,UAAU,QAAV,CAAmB,CAAnB,CAAzC;AACA,YAAG,CAAC,YAAJ,EAAkB;AACd,mBADc,CACN;AACX;AACD,qBAAa,OAAb,CAAqB,IAArB;AACA,kBAAU,YAAV;AACH;;AAED,QAAG,KAAK,IAAR,EAAc;AACV;AACA,oBAAY,KAAK,IAAL,EAAZ;AACH,KAHD,MAGO,IAAI,KAAK,kBAAT,EAA6B;AAChC;AACA,aAAK,IAAL,CAAU,SAAV,CAAoB,gBAAQ;AACxB,wBAAY,IAAZ;AACH,SAFD;AAGH;;AAED,WAAO,qBAAM,IAAN,EAAY;AACf;AADe,KAAZ,CAAP;AAGH,C;;AA7EL;;AACA;;AACA;;AACA;;AACA;;;;;;AAyEK","file":"menuViewModel.js","sourcesContent":["import { createViewModels, createViewModel } from 'scalejs.metadataFactory';\nimport { unwrap, computed, observable, observableArray } from 'knockout';\nimport { receive } from 'scalejs.messagebus';\nimport { merge, get } from 'scalejs';\nimport _ from 'lodash';\n\n    export default function (node) {\n        var keyMap = node.keyMap || {},\n            context = this,\n            base = createViewModel.call(this, merge(node, { type: 'template' })),\n            mappedChildNodes = observableArray(),\n            accordion;\n\n        function mapToAccordion(data) {\n            if (!data.sections) {\n                return {\n                    \"type\": \"template\",\n                    \"template\": \"empty_panel\",\n                }\n            }\n\n            let zipped = data.sections.map(section => {\n                    return [\n                        section.title,\n                        mapToAccordion(section)\n                    ]\n                }),\n                [sections, children] = _.unzip(zipped);\n            \n            return {\n                type: 'accordion',\n                isShown: observable(true),\n                // keep all menu items \"closed\" by default\n                // only allow one open menu at a time\n                options: {\n                    trueAccordion: true,\n                    openByDefault: false\n                },\n                template: 'menu_accordion',\n                sections,\n                children\n            }\n        }\n\n        function mapWorkflow(data) {\n            var workflow = get(data, keyMap.resultsKey || '', data);\n            // data will be converted to metadata in order to render accordions\n            accordion = createViewModel.call(context, mapToAccordion(workflow))\n            mappedChildNodes([accordion]);\n            \n            if (!workflow.openPanel) {\n                openFirst(accordion);\n            }\n        }        \n\n        function openFirst(accordion) {\n            let firstSection = accordion.sections && accordion.sections[0];\n            if(!firstSection) {\n                return; // all done opening accordions\n            }\n            firstSection.visible(true);\n            openFirst(firstSection);\n        }\n\n        if(node.data) {            \n            // data loaded synchronously \n            mapWorkflow(base.data());\n        } else if (node.dataSourceEndpoint) {\n            // data loaded asynchronously\n            base.data.subscribe(data => {\n                mapWorkflow(data);\n            });\n        }\n        \n        return merge(node, {\n            mappedChildNodes\n        });\n    };\n"]}