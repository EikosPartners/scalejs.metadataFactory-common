{"version":3,"sources":["../../src/menu/menuViewModel.js"],"names":[],"mappings":";;;;;;;;kBAMmB,UAAU,IAAV,EAAgB;AAC3B,QAAI,SAAS,KAAK,MAAL,IAAe,EAA5B;AAAA,QACI,UAAU,IADd;AAAA,QAEI,OAAO,yBAAgB,IAAhB,CAAqB,IAArB,EAA2B,qBAAM,IAAN,EAAY,EAAE,MAAM,UAAR,EAAZ,CAA3B,CAFX;AAAA,QAGI,mBAAmB,gCAHvB;AAAA,QAII,SAJJ;;AAMA,aAAS,cAAT,CAAwB,IAAxB,EAA8B;AAC1B,YAAI,CAAC,KAAK,QAAV,EAAoB;AAChB,mBAAO;AACH,wBAAQ,UADL;AAEH,4BAAY;AAFT,aAAP;AAIH;;AAEG,qBAAS,KAAK,QAAL,CAAc,GAAd,CAAkB,mBAAW;AAClC,mBAAO,CACH,QAAQ,KADL,EAEH,eAAe,OAAf,CAFG,CAAP;AAIH,SALQ,CAAT;;AARsB,sBAcC,iBAAE,KAAF,CAAQ,MAAR,CAdD;;AAAA;;AAAA,YAcrB,QAdqB;AAAA,YAcX,QAdW;;;AAgB1B,eAAO;AACH,kBAAM,WADH;AAEH,qBAAS,0BAAW,IAAX,CAFN;AAGH;AACA;AACA,qBAAS;AACL,+BAAe,IADV;AAEL,+BAAe;AAFV,aALN;AASH,sBAAU,gBATP;AAUH,8BAVG;AAWH;AAXG,SAAP;AAaH;;AAED,aAAS,WAAT,CAAqB,IAArB,EAA2B;AACvB,YAAI,WAAW,mBAAI,IAAJ,EAAU,OAAO,UAAP,IAAqB,EAA/B,EAAmC,IAAnC,CAAf;AACA;AACA,oBAAY,yBAAgB,IAAhB,CAAqB,OAArB,EAA8B,eAAe,QAAf,CAA9B,CAAZ;AACA,yBAAiB,CAAC,SAAD,CAAjB;;AAEA,YAAI,CAAC,SAAS,SAAd,EAAyB;AACrB,sBAAU,SAAV;AACH;AACJ;;AAED,aAAS,SAAT,CAAmB,SAAnB,EAA8B;AAC1B,YAAI,eAAe,UAAU,QAAV,IAAsB,UAAU,QAAV,CAAmB,CAAnB,CAAzC;AACA,YAAG,CAAC,YAAJ,EAAkB;AACd,mBADc,CACN;AACX;AACD,qBAAa,OAAb,CAAqB,IAArB;AACA,kBAAU,YAAV;AACH;;AAED,QAAG,KAAK,IAAR,EAAc;AACV;AACA,oBAAY,KAAK,IAAL,EAAZ;AACH,KAHD,MAGO,IAAI,KAAK,kBAAT,EAA6B;AAChC;AACA,aAAK,IAAL,CAAU,SAAV,CAAoB,gBAAQ;AACxB,wBAAY,IAAZ;AACH,SAFD;AAGH;;AAED,WAAO,qBAAM,IAAN,EAAY;AACf;AADe,KAAZ,CAAP;AAGH,C;;AA7EL;;AACA;;AACA;;AACA;;AACA;;;;;;AAyEK","file":"menuViewModel.js","sourcesContent":["import { createViewModels, createViewModel } from 'scalejs.metadataFactory';\r\nimport { unwrap, computed, observable, observableArray } from 'knockout';\r\nimport { receive } from 'scalejs.messagebus';\r\nimport { merge, get } from 'scalejs';\r\nimport _ from 'lodash';\r\n\r\n    export default function (node) {\r\n        var keyMap = node.keyMap || {},\r\n            context = this,\r\n            base = createViewModel.call(this, merge(node, { type: 'template' })),\r\n            mappedChildNodes = observableArray(),\r\n            accordion;\r\n\r\n        function mapToAccordion(data) {\r\n            if (!data.sections) {\r\n                return {\r\n                    \"type\": \"template\",\r\n                    \"template\": \"empty_panel\",\r\n                }\r\n            }\r\n\r\n            let zipped = data.sections.map(section => {\r\n                    return [\r\n                        section.title,\r\n                        mapToAccordion(section)\r\n                    ]\r\n                }),\r\n                [sections, children] = _.unzip(zipped);\r\n            \r\n            return {\r\n                type: 'accordion',\r\n                isShown: observable(true),\r\n                // keep all menu items \"closed\" by default\r\n                // only allow one open menu at a time\r\n                options: {\r\n                    trueAccordion: true,\r\n                    openByDefault: false\r\n                },\r\n                template: 'menu_accordion',\r\n                sections,\r\n                children\r\n            }\r\n        }\r\n\r\n        function mapWorkflow(data) {\r\n            var workflow = get(data, keyMap.resultsKey || '', data);\r\n            // data will be converted to metadata in order to render accordions\r\n            accordion = createViewModel.call(context, mapToAccordion(workflow))\r\n            mappedChildNodes([accordion]);\r\n            \r\n            if (!workflow.openPanel) {\r\n                openFirst(accordion);\r\n            }\r\n        }        \r\n\r\n        function openFirst(accordion) {\r\n            let firstSection = accordion.sections && accordion.sections[0];\r\n            if(!firstSection) {\r\n                return; // all done opening accordions\r\n            }\r\n            firstSection.visible(true);\r\n            openFirst(firstSection);\r\n        }\r\n\r\n        if(node.data) {            \r\n            // data loaded synchronously \r\n            mapWorkflow(base.data());\r\n        } else if (node.dataSourceEndpoint) {\r\n            // data loaded asynchronously\r\n            base.data.subscribe(data => {\r\n                mapWorkflow(data);\r\n            });\r\n        }\r\n        \r\n        return merge(node, {\r\n            mappedChildNodes\r\n        });\r\n    };\r\n"]}